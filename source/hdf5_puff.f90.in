!************* THIS HEADER MUST NOT BE REMOVED *******************!
!** Copyright 2013-2016, University of Strathclyde              **!
!** Written by Jonathan Smith (Tech-X UK Ltd)                   **!
!** This program must not be copied, distributed or altered in  **!
!** any way without the prior permission of the above authors.  **!
!*****************************************************************!

module hdf5_puff

USE ArrayFunctions
USE TypesandConstants
USE Globals
USE ParallelSetUp
Use avWrite
use paratype
use HDF5
use lattice
!use MPI
implicit none 

contains

!> Leftover routine to write vars into a parameter file
!! This should write the input data used to create results
!! @param zDataFileName      - INPUT  - Data file name
!! @param iNodes             - INPUT  - Number of Nodes
!! @param iNumElectrons      - INPUT  - number of electrons
!! @param sLengthOfElm       - INPUT  - Element length
!! @param sStepSize          - INPUT  - Integration step size
!! @param nSteps             - INPUT  - Number of steps 
!! @param sLenEPulse 	     - INPUT  - L-electron pulse
!! @param sWigglerLength     - INPUT  - Wiggler length
!! @param sSigmaGaussian     - INPUT  - e-pulse sigma
!! @param sA0_Re,            - INPUT  - Initial field value (real)
!! @param sA0_Im,            - INPUT  - Initial field value (imag)
!! @param iTotalNumElectrons - INPUT  - Acutal Number of electrons used
!! @param nWaveEquations     - INPUT  - Number of Wave Equations
!! @param nElectronEquations - INPUT  - Number of Electron Equations
!! @param sZ                 - UPDATE - IN: Starting z position
!! @param iWriteNthSteps     - UPDATE - Steps to write data at
!! @param sSeedSigma         - INPUT  - Sigma of initial seed field
!! @param qSwitch            - UPDATE - Optional if letting electrons
!!                               evolve, field evolve,
!!                               diffraction, gauss inital field
!! @param qOK                - OUTPUT - Error flag
!! @todo work out fx,fy usage, and whether vars below eg sx0_offset
!! are still in use. Determine if we need an h5 equivalent.
!! Note, runInfo group in vsh5 file contains input filename

! These appear not to be present any more
! @param sx0_offset         - INPUT  - Electron offset value
! @param sy0_offset         - INPUT  - Electron offset value

  SUBROUTINE  WriteAttributeData(zDataFileName, &
       iNodes,&
       iNumElectrons, &
       sLengthOfElm, &
       sStepSize, &
       nSteps, &
       sLenEPulse, &
       sWigglerLength, &
       sSigmaGaussian, &
       sA0_Re, &
       sA0_Im, &
       rho,aw,epsilon,gamma_r, &
       kbeta, ff, &
       lam_w, lam_r, &
       npk_bar, &
       totalNumberElectrons, &
       nWaveEquations, &
       nElectronEquations, &  
       sZ, &
       iWriteNthSteps, &
       iIntWriteNthSteps, &
       sSeedSigma, &
       qSwitch, &
       fx, &
       fy, &
       qOK)

    IMPLICIT NONE


!  LIst of variables to write as attributes available at FssdsPuffin.f90 lines 250 - 375	
!
    CHARACTER(1024_IP), INTENT(IN) :: zDataFileName
    INTEGER(KIND=IP), INTENT(IN) :: iNodes(:)
    INTEGER(KIND=IP), INTENT(IN) :: iNumElectrons(:)
    REAL(KIND=WP),    INTENT(IN) :: sLengthOfElm(:)
    REAL(KIND=WP),    INTENT(IN) :: sStepSize
    INTEGER(KIND=IP), INTENT(IN) :: nSteps
    REAL(KIND=WP),    INTENT(IN) :: sLenEPulse(:)   
    REAL(KIND=WP),    INTENT(IN) :: sWigglerLength(:) 
    REAL(KIND=WP),    INTENT(IN) :: sSigmaGaussian(:)
    REAL(KIND=WP),    INTENT(IN) :: sA0_Re   
    REAL(KIND=WP),    INTENT(IN) :: sA0_Im   
    REAL(KIND=WP),    INTENT(IN) :: rho,aw,epsilon,gamma_r
    REAL(KIND=WP),    INTENT(IN) :: kbeta, ff
    real(kind=wp),    intent(in) :: lam_w, lam_r
    real(kind=wp),    intent(in) :: npk_bar
    INTEGER(KIND=IPL), INTENT(IN) :: totalNumberElectrons
    INTEGER(KIND=IP), INTENT(IN) :: nWaveEquations    
    INTEGER(KIND=IP), INTENT(IN) :: nElectronEquations
    REAL(KIND=WP),    INTENT(IN) :: sZ
    INTEGER(KIND=IP), INTENT(IN) :: iWriteNthSteps, iIntWriteNthSteps
    REAL(KIND=WP),    INTENT(IN) :: sSeedSigma(:)
    LOGICAL,          INTENT(IN) :: qSwitch(:)
    REAL(KIND=WP),    INTENT(IN) :: fx,fy
  
    LOGICAL,          INTENT(OUT) :: qOK      
!
! Define local variables
! 
! tParamFile   - Write Parameter data to file
! qOKL         - Local error flag
!	
    TYPE(cFileType) :: tParamFile
    LOGICAL         :: qOKL
!********************************************************
! BEGIN:-
! Set error flag to false         
    qOK = .FALSE.    

    If (tProcInfo_G%qROOT) Then

! Open the file to receive data output -
! This subroutine is in IO.f90 line 793
       tParamFile%qFormatted = .TRUE.
!       call InitBasicSDDSFile('Param' // TRIM(zDataFileName),  or some other init for HDF5
!       If (.NOT. qOKL) Goto 1000
    End If 

!  Set error flag and exit         
    qOK = .TRUE.				    
    GoTo 2000     

! Error Handler - Error log Subroutine in CIO.f90 line 709
1000 call Error_log('Error in hdf5_puff:WriteAttributeData',&
          tErrorLog_G)
    Print*,'Error in hdf5_puff:WriteAttributeData'
2000 CONTINUE
  END SUBROUTINE WriteAttributeData


!> Simple wrapper routine to write a string attribute into hdf5
!! Assumed that the padding is set up outside here
!! Assumed that the h5 dataspace is set up outside here.

  subroutine addH5StringAttribute(locHandle,attrName,attrValue,aspace_id)

    implicit none

    integer(HID_T), intent(in) :: locHandle   !< h5 handle of write location
    character(len=*), intent(in) :: attrName  !<attrib name
    character(len=*), intent(in) :: attrValue !<attrib value
    integer(HID_T), intent(in) :: aspace_id   !< Attribute Dataspace identifier
    ! Local vars
    integer(HID_T) :: attr_id                 !< Attribute identifier
    integer(HID_T) :: atype_id                !< Attribute Data type identifier
    integer(HSIZE_T) :: attr_string_len       !< Length of attribute string 
    integer(HSIZE_T), dimension(1) :: adims=(/1/) !< Attribute Data type identifier
    integer :: error                             !< Error flag

!    aname="vsType"
!    attr_data_string="vsVars"

    call h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)

    attr_string_len=len(trim(adjustl(attrValue)))

    call h5tset_size_f(atype_id, attr_string_len, error)

    call h5acreate_f(locHandle, attrName, atype_id, aspace_id, attr_id, error)

    call h5awrite_f(attr_id, atype_id, attrValue, adims, error) 

    call h5aclose_f(attr_id, error)

    call h5tclose_f(atype_id, error)

  end subroutine







!> Simple wrapper routine to write a float attribute into hdf5
!! Assumed that the padding is set up outside here
!! Assumed that the h5 dataspace is set up outside here.

  subroutine addH5FloatAttribute(locHandle,attrName,attrValue,aspace_id)
    
    implicit none

    integer(HID_T), intent(in) :: locHandle   !< h5 handle of write location
    character(LEN=*), intent(in) :: attrName  !<attrib name
    real(kind=wp), intent(in) :: attrValue !<attrib value
    integer(HID_T), intent(in) :: aspace_id   !< Attribute Dataspace identifier
    ! Local vars

    integer(HID_T) :: attr_id                 !< Attribute identifier
    integer(HID_T) :: atype_id                !< Attribute Data type identifier
    integer(HSIZE_T) :: attr_string_len       !< Length of attribute string 
    integer(HSIZE_T), dimension(1) :: adims=(/1/) !< Attribute Data type identifier
    integer :: error                             !< Error flag

!    aname="vsType"
!    attr_data_string="vsVars"

    call h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    call h5acreate_f(locHandle, attrName, atype_id, aspace_id, attr_id, error)
    call h5awrite_f(attr_id, atype_id, attrValue, adims, error) 
    call h5aclose_f(attr_id, error)
    call h5tclose_f(atype_id, error)

  end subroutine addH5FloatAttribute






  subroutine addH5IntegerAttribute(locHandle,attrName,attrValue,aspace_id)

    implicit none

    integer(HID_T), intent(in) :: locHandle   !< h5 handle of write location
    character(LEN=*), intent(in) :: attrName  !<attrib name
    integer(kind=IP), intent(in) :: attrValue !<attrib value
    integer(HID_T), intent(in) :: aspace_id   !< Attribute Dataspace identifier

    ! Local vars

    integer(HID_T) :: attr_id                 !< Attribute identifier
    integer(HID_T) :: atype_id                !< Attribute Data type identifier
    integer(HSIZE_T) :: attr_string_len       !< Length of attribute string 
    integer(HSIZE_T), dimension(1) :: adims=(/1/) !< Attribute Data type identifier
    integer :: error                             !< Error flag
!    aname="vsType"
!    attr_data_string="vsVars"

    call h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
    call h5acreate_f(locHandle, attrName, atype_id, aspace_id, attr_id, error)
    call h5awrite_f(attr_id, atype_id, attrValue, adims, error) 
    call h5aclose_f(attr_id, error)
    call h5tclose_f(atype_id, error)

  end subroutine addH5IntegerAttribute



!> addH5derivedVariable() add vizschema derived variable
  subroutine addH5derivedVariable(location,varName,expression,error)

    implicit none

    integer(HID_T), intent(in) :: location !< h5 handle of write location
    character(len=*), intent(in) :: varName !<derived var name
    character(len=*), intent(in) :: expression !<expression value

    ! Local vars

    integer(HID_T) :: group_id      !< Group identifier
    integer(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    integer :: error ! Error flag

!               We make a new group

    call h5gcreate_f(location, varName, group_id, error)
    call h5screate_f(H5S_SCALAR_F, aspace_id, error)
    call addH5StringAttribute(group_id,"vsType","vsVars",aspace_id)
    call addH5StringAttribute(group_id,varName,expression,aspace_id)
    call h5sclose_f(aspace_id, error)
    call h5gclose_f(group_id, error)

  end subroutine addH5derivedVariable

!> addH5derivedVariable() add vizschema derived variable
  subroutine addH5derivedVariableSI(location,varName,expression,meshname,error)

    implicit none

    integer(HID_T), intent(in) :: location !< h5 handle of write location
    character(len=*), intent(in) :: varName !<derived var name
    character(len=*), intent(in) :: expression !<expression value
    character(len=*), intent(in) :: meshname !<expression value

    ! Local vars

    integer(HID_T) :: group_id      !< Group identifier
    integer(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    integer :: error ! Error flag

!               We make a new group

    call h5gcreate_f(location, varName, group_id, error)
    call h5screate_f(H5S_SCALAR_F, aspace_id, error)
    call addH5StringAttribute(group_id,"vsType","vsVars",aspace_id)
    call addH5StringAttribute(group_id,"vsMesh",trim(adjustl(meshname // "SI")),aspace_id)
!    call addH5StringAttribute(group_id,"vsLimits","globalLimitsSI",aspace_id)
    call addH5StringAttribute(group_id,varName,expression,aspace_id)
    call h5sclose_f(aspace_id, error)
    call h5gclose_f(group_id, error)

  end subroutine addH5derivedVariableSI




!> Write a 3D array of real, floating point values

  subroutine write3DfloatAttribute(location, aname, valarray)

    implicit none

    integer(HID_T), intent(in) :: location   !< h5 handle of write location
    character(LEN=*), intent(in) :: aname    !<derived var name
    real(kind=wp), intent(in) :: valarray(:) !<the array to be written
    integer(HSIZE_T), dimension(1) :: adims=(/3/)  !< Attribute dims
    integer        ::  arank = 1                !< Attribute rank - 1 is vector
    integer(HID_T) :: aspace_id              !< Attribute Dataspace identifier
    integer(HID_T) :: atype_id                !< Attribute Data type identifier
    integer(HID_T) :: attr_id                 !< Attribute identifier
    integer        :: error                   !< Error flag

    call h5screate_simple_f(arank, adims, aspace_id, error)
    call h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    call h5acreate_f(location, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:write3DfloatAttribute(' // trim(adjustl(aname)) // ')'
!    ALLOCATE ( limdata(numSpatialDims))
!    limdata(1)=-0.5*(NX_G-1_IP)*sLengthOfElmX_G
!    limdata(2)=-0.5*(NY_G-1_IP)*sLengthOfElmY_G
!    limdata(3)=0.0
    call h5awrite_f(attr_id, atype_id, valarray, adims, error) 
!    Print*,error
    call h5aclose_f(attr_id, error)
!    Print*,error
    call h5tclose_f(atype_id, error)
    call h5sclose_f(aspace_id, error)

  end subroutine write3DfloatAttribute






!> Write a 3D array of integer values

  subroutine write3DintAttribute(location, aname, valarray)

    implicit none

    integer(HID_T), intent(in) :: location   !< h5 handle of write location
    character(LEN=*), intent(in) :: aname    !<derived var name
    integer(kind=IP), intent(in) :: valarray(:) !<the array to be written
    integer(HSIZE_T), dimension(1) :: adims=(/3/)  !< Attribute dims
    integer        ::  arank = 1                !< Attribute rank - 1 is vector
    integer(HID_T) :: aspace_id              !< Attribute Dataspace identifier
    integer(HID_T) :: atype_id                !< Attribute Data type identifier
    integer(HID_T) :: attr_id                 !< Attribute identifier
    integer        :: error                   !< Error flag


    call h5screate_simple_f(arank, adims, aspace_id, error)

    call h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)

    call h5acreate_f(location, aname, atype_id, aspace_id, attr_id, error)

    call h5awrite_f(attr_id, atype_id, valarray, adims, error) 

    call h5aclose_f(attr_id, error)

    call h5tclose_f(atype_id, error)

    call h5sclose_f(aspace_id, error)

  end subroutine write3DintAttribute








!> Subroutine to write 3d limit data

  subroutine write3DlimGrp(location,limgrpname,lb,ub)
    
    implicit none

    integer(HID_T), intent(in) :: location        !< h5 handle of write location
    character(len=*), intent(in) :: limgrpname    !<derived var name
    real(kind=wp), dimension(3), intent(in) :: ub(:), lb(:)     !<Bounds to write
    integer(HID_T) :: group_id      !< Group identifier
    integer        :: error                   !< Error flag
    integer(HID_T) :: aspace_id              !< Attribute Dataspace identifier

    call h5gcreate_f(location, limgrpname, group_id, error)

    call h5screate_f(H5S_SCALAR_F, aspace_id, error)

    call addH5StringAttribute(group_id,"vsType","limits",aspace_id)

    call addH5StringAttribute(group_id,"vsKind","Cartesian",aspace_id)

    call write3DfloatAttribute(group_id, "vsLowerBounds", lb)

    call write3DfloatAttribute(group_id, "vsUpperBounds", ub)

    call h5sclose_f(aspace_id, error)    

    call h5gclose_f(group_id, error)

  end subroutine write3DlimGrp







!> Subroutine to write 1d or limit data

  subroutine write1DlimGrp(location,limgrpname,lb,ub)
    
    implicit none
    
    integer(HID_T), intent(in) :: location        !< h5 handle of write location
    character(len=*), intent(in) :: limgrpname    !<derived var name
    real(kind=wp), intent(in) :: ub, lb           !<Bounds to write
    integer(HID_T) :: group_id                    !< Group identifier
    integer        :: error                       !< Error flag
    integer(HID_T) :: aspace_id                   !< Attribute Dataspace identifier

    call h5gcreate_f(location, limgrpname, group_id, error)

    call h5screate_f(H5S_SCALAR_F, aspace_id, error)

    call addH5StringAttribute(group_id,"vsType","limits",aspace_id)

    call addH5StringAttribute(group_id,"vsKind","Cartesian",aspace_id)

    call addH5FloatAttribute(group_id, "vsLowerBounds", lb,aspace_id)

    call addH5FloatAttribute(group_id, "vsUpperBounds", ub,aspace_id)

    call h5sclose_f(aspace_id, error)    

    call h5gclose_f(group_id, error)

  end subroutine write1DlimGrp






!> Subroutine to write 3d mesh data

  subroutine write3DuniformMesh(location,meshname,lb,ub,numcells)

    implicit none

    integer(HID_T), intent(in) :: location        !< h5 handle of write location
    character(len=*), intent(in) :: meshname    !<derived var name
    real(kind=wp), dimension(3), intent(in) :: ub(:), lb(:)     !<Bounds to write
    integer(kind=ip), dimension(3), intent(in) :: numcells(:) !<the array to be written
    integer(HID_T) :: group_id      !< Group identifier
    integer        :: error                   !< Error flag
    integer(HID_T) :: aspace_id              !< Attribute Dataspace identifier


    call h5gcreate_f(location, meshname, group_id, error)

    call h5screate_f(H5S_SCALAR_F, aspace_id, error)

    call addH5StringAttribute(group_id,"vsType","mesh",aspace_id)

    call addH5StringAttribute(group_id,"vsKind","uniform",aspace_id)

    call addH5StringAttribute(group_id,"vsCentering","nodal",aspace_id)

    call addH5StringAttribute(group_id,"vsIndexOrder","compMajorF",aspace_id)

    call h5sclose_f(aspace_id, error)    

    call write3DfloatAttribute(group_id, "vsLowerBounds", lb)

    call write3DfloatAttribute(group_id, "vsUpperBounds", ub)

    call write3DintAttribute(group_id, "vsStartCell", (/0,0,0/))

    call write3DintAttribute(group_id, "vsNumCells", numcells)

    call h5gclose_f(group_id, error)

  end subroutine write3DuniformMesh





  !> Subroutine to write 1d mesh data

  subroutine write1DuniformMesh(location,meshname,lb,ub,numcells,labels)

    implicit none

    integer(HID_T), intent(in) :: location        !< h5 handle of write location
    character(len=*), intent(in) :: meshname    !<derived var name
    character(len=*), intent(in) :: labels    !<derived var name
    real(kind=wp), intent(in) :: ub, lb   !<Bounds to write
    integer(kind=IP), intent(in) :: numcells !<the array to be written
    integer(kind=IP) :: startcell=0 !<another array to be written
    integer(HID_T) :: group_id      !< Group identifier
    integer        :: error                   !< Error flag
    integer(HID_T) :: aspace_id              !< Attribute Dataspace identifier

    call h5gcreate_f(location, meshname, group_id, error)
    call h5screate_f(H5S_SCALAR_F, aspace_id, error)
    call addH5StringAttribute(group_id,"vsType","mesh",aspace_id)
    call addH5StringAttribute(group_id,"vsKind","uniform",aspace_id)
    call addH5StringAttribute(group_id,"vsCentering","nodal",aspace_id)
    call addH5StringAttribute(group_id,"vsIndexOrder","compMajorF",aspace_id)
    call addH5StringAttribute(group_id,"vsAxisLabels",labels,aspace_id)
    call addH5FloatAttribute(group_id, "vsLowerBounds", lb,aspace_id)
    call addH5FloatAttribute(group_id, "vsUpperBounds", ub,aspace_id)
    call addH5IntegerAttribute(group_id, "vsStartCell", startcell,aspace_id)
    call addH5IntegerAttribute(group_id, "vsNumCells", numcells,aspace_id)

    call h5sclose_f(aspace_id, error)    

    call h5gclose_f(group_id, error)

  end subroutine write1DuniformMesh






  subroutine writeCommonAtts(dset_id, simtime, z_loc, iL, aspace_id)

    integer(HID_T), intent(in) :: dset_id   !< h5 handle of write location
    real(kind=wp), intent(in) :: simtime   !< Current simulation 'time' (zbar)
    real(kind=wp), intent(in) :: z_loc     !< zbar local to current undulator module
    integer(kind=ip), intent(in) :: iL        !< lattice element counter
    integer(HID_T), intent(in) :: aspace_id   !< h5 handle of write location

    CALL addH5FloatAttribute(dset_id, "time", simtime, aspace_id)
    
    call addH5FloatAttribute(dset_id, "zbarTotal", simtime, aspace_id)
    call addH5FloatAttribute(dset_id, "zTotal", simtime * lg_G, aspace_id)

    CALL addH5FloatAttribute(dset_id, "zbarInter", sZi_G, aspace_id)
    CALL addH5FloatAttribute(dset_id, "zInter", sZi_G * lg_G, aspace_id)
    
    call addH5FloatAttribute(dset_id, "zbarLocal", z_loc, aspace_id)
    call addH5FloatAttribute(dset_id, "zLocal", z_loc * lg_G,aspace_id)

    CALL addH5IntegerAttribute(dset_id, "iCsteps", iCsteps, aspace_id)
    CALL addH5IntegerAttribute(dset_id, "istep", istep, aspace_id)
    
    call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  

  end subroutine writeCommonAtts



  subroutine writeRunAtts(dset_id, aspace_id)

    integer(HID_T), intent(in) :: dset_id     !< h5 handle of write location
    !real(kind=wp), intent(in) :: simtime      !< Current simulation 'time' (zbar)
    !real(kind=wp), intent(in) :: z_loc        !< zbar local to current undulator module
    !integer(kind=ip), intent(in) :: iL        !< lattice element counter
    integer(HID_T), intent(in) :: aspace_id   !< h5 handle of write location

!    CALL addH5FloatAttribute(dset_id, "time", simtime, aspace_id)
    
!    call addH5FloatAttribute(dset_id, "zbarTotal", simtime, aspace_id)
!    call addH5FloatAttribute(dset_id, "zTotal", simtime * lg_G, aspace_id)

!    CALL addH5FloatAttribute(dset_id, "zbarInter", sZi_G, aspace_id)
!    CALL addH5FloatAttribute(dset_id, "zInter", sZi_G * lg_G, aspace_id)
    
!    call addH5FloatAttribute(dset_id, "zbarLocal", z_loc, aspace_id)
!    call addH5FloatAttribute(dset_id, "zLocal", z_loc * lg_G,aspace_id)

!    CALL addH5IntegerAttribute(dset_id, "iCsteps", iCsteps, aspace_id)
!    CALL addH5IntegerAttribute(dset_id, "istep", istep, aspace_id)
    
    call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
    call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    
    call addH5IntegerAttribute(dset_id, 'nX', nX_G, aspace_id)  
    call addH5IntegerAttribute(dset_id, 'nY', nY_G, aspace_id)  
    call addH5IntegerAttribute(dset_id, 'nZ2', nZ2_G, aspace_id)  
    
    call addH5FloatAttribute(dset_id, 'sLengthOfElmX', sLengthOfElmX_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'sLengthOfElmY', sLengthOfElmY_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'sLengthOfElmZ2', sLengthOfElmZ2_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'sStepSize', sStepSize, aspace_id)  
    call addH5IntegerAttribute(dset_id, 'nSteps', nSteps, aspace_id)  
    call addH5FloatAttribute(dset_id, 'rho', sRho_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'aw', sAw_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'eta', seta_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'gamma_r', sGammaR_G, aspace_id)
    call addH5FloatAttribute(dset_id, 'kappa', sKappa_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'npk_bar', npk_bar_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'Lg', lg_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'Lc', lc_G, aspace_id)  
    call addH5FloatAttribute(dset_id, 'lambda_w', lam_w_G, aspace_id)
    call addH5FloatAttribute(dset_id, 'lambda_r', lam_r_G, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'qOneD', qOneD_G, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  
    !call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)  

  end subroutine writeRunAtts
  
  




!> Overall script to write the larger full h5 output data files
!! Not including the integrated quantities
!! @ Todo remove unused vars - filename parameters are not required.

  subroutine wr_h5(sZ, sZ_loc, tArrayA, tArrayE, tArrayZ, iL, &
                   iIntWr, iWr, qSep, zDFname, qWriteFull, &
                   qWriteInt, nslices, qOK)

    implicit none

    real(kind=wp), intent(in) :: sZ, sZ_loc  !< zbar and local zbar for current module
    real(kind=wp), dimension(NZ2_G) :: power !<power data (called here)
    real(kind=wp), dimension(npts_I_G) :: Iarray !< current data (called here)
    type(cArraySegment), intent(inout) :: tArrayA(:), tArrayE(:), tArrayZ
    integer(kind=ip), intent(in)  :: nslices, iL
    real(kind=wp), dimension(nslices) :: aveX,aveY,avePX,avePY,aveGamma,aveDgamma
    real(kind=wp), dimension(nslices) :: sdX, sdY, sdpx, sdpy, eX, ey, aX, aY, bX, bY
    real(kind=wp), dimension(nslices) :: bun1,bun2,bun3,bun4,bun5,sq

    integer(kind=ip), intent(in) :: iIntWr, iWr !<Aren't these global?
    character(1024_IP), intent(in) :: zDFName 
    logical, intent(in) :: qSep !< Probably not used here, whether to write separate files
    logical, intent(inout) :: qOK  !< Flag set if any probs happen
    integer :: error, numSpatialDims
    real(kind=wp) :: slicetrim
    logical :: qWriteInt, qWriteFull !<Flags identifying if it is time to write
    real(kind=wp) :: time,stime,ftime !<Simulation time, calcualted here
    real(kind=wp) :: PowScale !< Scaling factor for power
    error = 0
    slicetrim=(4*pi*srho_g*nslices)-sLengthOfElmZ2_G*NZ2_G

! now this is passed in so that we can set the arrays properly

    !    nslices = int( (sLengthOfElmZ2_G*NZ2_G)/(4*pi*srho_g))

    time = sZ

    if (qWriteFull) then

!      time = sZ ! real(iCSteps,kind=wp)*sStepSize*lg_G/c

      if (qSep) then
!        print *,'Dumping particles individually...'

        call cpu_time(stime)
        call outputH5BeamFilesID(time, sz_loc, iL, error)
        call cpu_time(ftime)
!        print '("Dumped particles separately. Took time = ",f6.3," secs on rank ",i5)'&
!          ,ftime-stime,tProcInfo_G%rank

      else 

!        print *,'Dumping particles to single file...'
        call cpu_time(stime)
        call outputH5BeamFilesSD(time, sz_loc, iL, error)
        call cpu_time(ftime)
!        print '("Dumped particles to one file. Took time = ",f6.3," seconds on rank ",i5)'&
!          ,ftime-stime,tProcInfo_G%rank

      end if

      if (error .ne. 0) goto 1000

      if (qONED_G) then

        numSpatialDims=1

!      print *,'2 component 1D field output not currently supported'
!        print *, "But trying anyway - Dumping all fields together"
        call cpu_time(stime)
        call outputH5Field1D2CompSD(time, sz_loc, iL, error, tlflen, fr_rfield,  ffs, ffe, 0, 1, .false.)
        call outputH5Field1D2CompSD(time, sz_loc, iL, error, tlflen, fr_ifield,  ffs, ffe, 1, 2, .false.)
        call outputH5Field1D2CompSD(time, sz_loc, iL, error, mainlen, ac_rfield, fz2, ez2, 0, 2, .true.)
        call outputH5Field1D2CompSD(time, sz_loc, iL, error, mainlen, ac_ifield, fz2, ez2, 1, 2, .true.)
        call outputH5Field1D2CompSD(time, sz_loc, iL, error, tlelen, bk_rfield,  ees, eee, 0, 2, .false.)
        call outputH5Field1D2CompSD(time, sz_loc, iL, error, tlelen, bk_ifield,  ees, eee, 1, 2, .false.)
        call cpu_time(ftime)

!        print '("Dumped fields together. Took time = ",f6.3," secs on rank ",i5)' &
!          ,ftime-stime,tprocinfo_g%rank

      ! todo generalize/split 1D field output to take two component fields.
! to do raw data write in one place, and prob limits, and write other
! field attributes which are shared elsewhere. Lims are the same. Mesh
! is (probably) the same

! signature: nlonglength, dsetname, data, nlo, nhi, chkactiveflag
! tlflen, 'aperp_front_real', fr_rfield, [ffs,ffe], .false.
! tlflen, 'aperp_front_imag', fr_ifield, [ffs,ffe], .false.
! mainlen, 'aperp_active_real', ac_rfield, [fz2,ez2], .true.
! mainlen, 'aperp_active_imag', ac_ifield, [fz2,ez2], .true.
! tlelen, 'aperp_back_real', bk_rfield, [ees,eee], .false.
! tlelen, 'aperp_back_imag', bk_ifield, [ees,eee], .false.
! final argument  checks for all active field on single root node ... 
! should say if qUnique or rank=0...

!!!
! This is the behaviour for individual dumping.
!


      else
      
        numSpatialDims=3
      
        if (qSep) then

!        print *, "Dumping separate fields"

          call cpu_time(stime)
          call outputH5Field3DID(time, sz_loc, iL, error, tlflen, 'aperp_front_real', fr_rfield,  ffs, ffe, .false.)
          call outputH5Field3DID(time, sz_loc, iL, error, tlflen, 'aperp_front_imag', fr_ifield,  ffs, ffe, .false.)
          call outputH5Field3DID(time, sz_loc, iL, error, mainlen, 'aperp_active_real', ac_rfield,  fz2, ez2, .true.)
          call outputH5Field3DID(time, sz_loc, iL, error, mainlen, 'aperp_active_imag', ac_ifield,  fz2, ez2, .true.)
          call outputH5Field3DID(time, sz_loc, iL, error, tlelen, 'aperp_back_real', bk_rfield,  ees, eee, .false.)
          call outputH5Field3DID(time, sz_loc, iL, error, tlelen, 'aperp_back_imag', bk_rfield,  ees, eee, .false.)
          call cpu_time(ftime)
!        print '("Dumped separate fields. Took time = ",f6.3," secs on rank ",i5)' &
!          ,ftime-stime,tprocinfo_g%rank

        else

!        print *, "Dumping all fields together"
          call cpu_time(stime)
          call outputH5Field3DSD(time, sz_loc, iL, error, tlflen, fr_rfield,  ffs, ffe, 0, 1, .false.)
          call outputH5Field3DSD(time, sz_loc, iL, error, tlflen, fr_ifield,  ffs, ffe, 1, 2, .false.)
          call outputH5Field3DSD(time, sz_loc, iL, error, mainlen, ac_rfield, fz2, ez2, 0, 2, .true.)
          call outputH5Field3DSD(time, sz_loc, iL, error, mainlen, ac_ifield, fz2, ez2, 1, 2, .true.)
          call outputH5Field3DSD(time, sz_loc, iL, error, tlelen, bk_rfield,  ees, eee, 0, 2, .false.)
          call outputH5Field3DSD(time, sz_loc, iL, error, tlelen, bk_ifield,  ees, eee, 1, 2, .false.)
          call cpu_time(ftime)
!        print '("Dumped fields together. Took time = ",f6.3," secs on rank ",i5)' &
!          ,ftime-stime,tprocinfo_g%rank
        end if
!      call outputH5Field3DSDattrs(time, error, tlflen, fr_rfield,  ffs, ffe, 0, .false.)
        if (error .ne. 0) goto 1000

      end if

! Zposition is probably to be recorded not at each timestep
! Todo: move into main
!      call outputH5Z(sZ, tArrayZ, iStep, qSep, zDFName, qOKL)
!      if (.not. qOKL) goto 1000

    end if



    if (qWriteInt) then

! These call requires all ranks to participate
      call gPowerP(power)
      call getCurr(dz2_I_G, Iarray)
      call getSliceTwiss(nslices,slicetrim,aveX,aveY,avePX,avePY, &
        sdX,sdY,sdpx,sdpy,eX,eY,ax,ay,bx,by,aveGamma,aveDgamma, &
        bun1,bun2,bun3,bun4,bun5,sq)

! For starters, write on rank 0 only


! but the write operation does not, as the data has been collected on rank0.

      if (tProcInfo_G%qRoot) then
!        time = sZ*lg_G/c !real(iCSteps,kind=wp)*sStepSize*lg_G/c
        if (qSep) then
      
          call outputH5Field1DFloat(power, 'power', time, sz_loc, iL, error)
          call outputH5Field1DFloat(Iarray, 'beamCurrent', time, sz_loc, iL, error)
          call outputH5Field1DFloat(aveX, 'meanPosX', time, sz_loc, iL, error)
          call outputH5Field1DFloat(aveY, 'meanPosY', time, sz_loc, iL, error)
          call outputH5Field1DFloat(avepy, 'meanMomentumX', time, sz_loc, iL, error)
          call outputH5Field1DFloat(avepy, 'meanMomentumY', time, sz_loc, iL, error)
          call outputH5Field1DFloat(aveGamma, 'meanGamma', time, sz_loc, iL, error)
          call outputH5Field1DFloat(aveDGamma, 'meanDeltaGamma', time, sz_loc, iL, error)
          call outputH5Field1DFloat(sdx, 'sigmaX', time, sz_loc, iL, error)
          call outputH5Field1DFloat(sdy, 'sigmaY', time, sz_loc, iL, error)
          call outputH5Field1DFloat(sdpx, 'sigmapX', time, sz_loc, iL, error)
          call outputH5Field1DFloat(sdpy, 'sigmapY', time, sz_loc, iL, error)
          call outputH5Field1DFloat(ex, 'emittanceX', time, sz_loc, iL, error)
          call outputH5Field1DFloat(ey, 'emittanceY', time, sz_loc, iL, error)
          call outputH5Field1DFloat(bun1, 'bunchingFundamental', time, sz_loc, iL, error)
          call outputH5Field1DFloat(bun2, 'bunching2ndHarmonic', time, sz_loc, iL, error)
          call outputH5Field1DFloat(bun3, 'bunching3rdHarmonic', time, sz_loc, iL, error)
          call outputH5Field1DFloat(bun4, 'bunching4thHarmonic', time, sz_loc, iL, error)
          call outputH5Field1DFloat(bun5, 'bunching5thHarmonic', time, sz_loc, iL, error)
          call outputH5Field1DFloat(sq, 'sliceCharge', time, sz_loc, iL, error)
        else

          PowScale = lg_G * lc_G * c * e_0 * ((sgammaR_G * m_e * c**2.0_wp ) / &
                                 (q_e * skappa_G * lg_G ))**2.0_wp

          call CreateIntegrated1DFloat(time,error,nslices)
          call addH5Field1DFloat(power, 'power', PowScale, "intFieldMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(Iarray, 'beamCurrent', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(aveX, 'meanPosX', (DSQRT(lg_G*lc_G)), "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(aveY, 'meanPosY', (DSQRT(lg_G*lc_G)), "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(avepy, 'meanMomentumX', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(avepy, 'meanMomentumY', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(aveGamma, 'meanGamma', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(aveDGamma, 'meanDeltaGamma', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(sdx, 'sigmaX', (DSQRT(lg_G*lc_G)), "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(sdy, 'sigmaY', (DSQRT(lg_G*lc_G)), "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(sdpx, 'sigmapX', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(sdpy, 'sigmapY', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(ex, 'emittanceX', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(ey, 'emittanceY', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(bun1, 'bunchingFundamental', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(bun2, 'bunching2ndHarmonic', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(bun3, 'bunching3rdHarmonic', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(bun4, 'bunching4thHarmonic', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(bun5, 'bunching5thHarmonic', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
          call addH5Field1DFloat(sq, 'sliceCharge', 1._wp, "intPtclMesh", time, sz_loc, iL, error)
        end if
!        call addH5integratedField(Iarray, 'beamCurrent',error)
        if (error .ne. 0) goto 1000
! Todo not yet implemented
!     call outputH5SliceEmittance
!       NOT YET IMPLEMENTED

      end if  

    end if

!  Set error flag and exit         

    error = 0            

    goto 2000     

! Error Handler - Error log Subroutine in CIO.f90 line 709

1000 call Error_log('Error in hdfPuffin:wr_h5',&
          tErrorLog_G)
    print*,'Error in hdfPuffin:wr_h5'
2000 continue

  end subroutine wr_h5

!> Output the electron bean macroparticle 
!! 6D phase space coordinates (plus weight) in Puffin.
!! For one file per rank only at the moment
!! @params unused tArrayE global array (to this rank) 
!! containing particles and layout of data in sV.
!! @params sElX_G, particle x coordinate
!! @params sElY_G, particle y coordinate
!! @params sElZ2_G, particle z2 (displacement from bunch centre)
!! @params iNumberElectrons_G number of electrons (global) on this rank
!! @todo Individual and collective writing to combined file to come
!! For collective write, we want to work out how many particles on 
!! each rank, what the cumulative num electrons is, and then determine
!! the array slice based on that.

  subroutine outputH5BeamFilesID(time, sz_loc, iL, error)
    
    implicit none
    
    real(kind=wp),intent(in) :: time !< Current time
    real(kind=wp),intent(in) :: sz_loc
    integer(kind=ip), intent(in) :: iL !< Lattice element number
    integer(HID_T) :: file_id        !< File identifier
    integer(HID_T) :: dset_id        !< Dataset identifier 
    integer(HID_T) :: dspace_id      !< Dataspace identifier in memory
    integer(HID_T) :: filespace      !< Dataspace identifier in file
    integer(HID_T) :: attr_id        !< Attribute identifier
    integer(HID_T) :: aspace_id      !< Attribute Dataspace identifier
    integer(HID_T) :: atype_id       !< Attribute Data type identifier
    integer(HID_T) :: group_id       !< Group identifier
!    logical, intent(in) :: qSeparate !<May reinstitute this.
    CHARACTER(LEN=9), PARAMETER :: dsetname = "electrons" !< Dataset name
    CHARACTER(LEN=30) :: aname   !< Attribute name
    character(1024_IP) :: filename
!    logical, intent(inout) :: qOK
!    integer(HSIZE_T), DIMENSION(1) :: dims = (/iGloNumElectrons_G/) ! Dataset dimensions
    integer(HSIZE_T), dimension(2) :: dims   !< dims of ptcl dataset (coords*numelecs)
    integer(HSIZE_T), dimension(2) :: doffset!< Offset for write, could be rank dependent
    integer(HSIZE_T), dimension(2) :: dsize  !< Size of hyperslab to write
    integer     ::  rank = 2                 !< Particle Dataset rank
    integer     ::  arank = 1                !< Attribute rank - 1 is vector
    integer(HSIZE_T), dimension(1) :: adims  !< Attribute dims
    integer(HSIZE_T), dimension(1) :: attr_data_int !< For integer attribs (numdims)
    integer     :: numSpatialDims    !< Attr content, and also num elsewhere  
!assumed 3D sim. May be 1D.
!    TYPE(C_PTR) :: f_ptr
    real(kind=wp) :: attr_data_double
    character(len=100) :: attr_data_string
    character(len=16) :: scaleToSIstring
    integer(HSIZE_T) :: attr_string_len
    character(len=4), parameter :: timegrpname = "time"  ! Group name
    character(len=12), parameter :: limgrpname = "globalLimits"  ! Group name
    real(kind=wp), allocatable :: limdata (:)  ! Data to write
    ! Local vars
    !integer(kind=ip) :: iep
    integer :: error ! Error flag

    if (qONED_G) then
      numSpatialDims=1
    else
      numSpatialDims=3
    end if
!    print*,'Writing electron data on rank', tProcInfo_G%rank

    attr_data_int(1)=numSpatialDims
    adims(1)=1 
    adims = (/1/) 
    dims = (/7,iNumberElectrons_G/) ! Dataset dimensions
    doffset=(/0,0/)
    dsize=(/1,iNumberElectrons_G/)
    attr_data_string="electrons_x,electrons_y,electrons_z,electrons_px," // &
      "electrons_py,electrons_gamma,electrons_weight"
    attr_string_len=94

! Prepare filename

    filename = ( trim(adjustl(zFilename_G)) // '_electrons_' // &
                 trim(adjustl(IntegerToString(tProcInfo_G%Rank))) // &
		 '_' // trim(adjustl(IntegerToString(iCSteps))) // '.h5' )

    CALL h5open_f(error)
!    Print*,'hdf5_puff:outputH5BeamFiles(file opened)'

! Create a new file using default properties.
    CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(file created)'

! Create the big dataspace in the file.
    CALL h5screate_simple_f(rank, dims, filespace, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(filespace created)'

! Create the dataset with default properties.
    CALL h5dcreate_f(file_id, dsetname, H5T_NATIVE_DOUBLE, filespace, &
       dset_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(dataset created)'
    CALL h5sclose_f(filespace, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(filespace closed)'

! Create a smaller space to buffer the data writes
    CALL h5screate_simple_f(rank, dsize, dspace_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(memory dataspace allocated)'
! Select hyperslab in the file.
    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)   
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElX_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)

! End access to the dataset and release resources used by it.
    CALL h5sclose_f(filespace, error) 
!    CALL h5sclose_f(dspace_id, error) 
  
! repeat for some next y dataset
    doffset=(/1,0/)
    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElY_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

!
! repeat for some next z dataset
    doffset=(/2,0/)
    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElZ2_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

! repeat for some next px dataset
    doffset=(/3,0/)
    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElPX_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

! repeat for some next py dataset
    doffset=(/4,0/)
    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElPY_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

! repeat for some next gamma dataset (actually beta*gamma)
    doffset=(/5,0/)

    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElgam_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 
!
! 
! put Chi in the file, slightly redundant as charge on a macroparticle
! doesn't increase or decrease through the simulation. But does make
! Everything self contained. Perhaps we use in future a funky h5 technique
! to point this column at a separate file which holds the data, reducing 
! the size of this column from every written file.
    doffset=(/6,0/)

    CALL H5Dget_space_f(dset_id, filespace, error)
    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
       dsize, error)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, s_chi_bar_G, dims, error, &
       file_space_id = filespace, mem_space_id = dspace_id)
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 
! Terminate access to the data space.
!
    CALL h5sclose_f(dspace_id, error)  
!
! ATTRIBUTES FOR PARTICLE DATASET
!
! simple dataset for array of vals
!    CALL h5screate_simple_f(arank, adims, aspace_id, error)

! scalar dataset for simpler values
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!
! Create datatype for the attribute.
!
    CALL h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
!    CALL h5tset_size_f(atype_id, attrlen, error)
!
! Create dataset attribute.
!
    aname = "vsNumSpatialDims"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
! Write the attribute data.
    CALL h5awrite_f(attr_id, atype_id, numSpatialDims, adims, error) !
! Close the attribute.
    CALL h5aclose_f(attr_id, error)
! next attribute
    aname="numSpatialDims"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, numSpatialDims, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)

! integers done, move onto floats
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
!    aname="time"
!    attr_data_double=time
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
! then
    aname="mass"
!    attr_data_double=9.10938356E-31
    attr_data_double=m_e
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="charge"
!    attr_data_double=1.602176487E-19
    attr_data_double=q_e
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(charge written)'
    aname="numTotalPhysicalParticles"
    attr_data_double=npk_bar_G*q_e
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)


    call writeCommonAtts(dset_id, time, sz_loc, iL, aspace_id)

    
!    call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)
!    
!    aname="zbarInter"
!    attr_data_double=time !real(iCSteps,kind=wp)*sStepSize*lg_G
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
!    aname="zInter"
!    attr_data_double=time*lg_G !real(iCSteps,kind=wp)*sStepSize*lg_G
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
    aname="gainLength"
    attr_data_double=lg_G
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="cooperationLength"
    attr_data_double=lc_G
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)

! then text attributes
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(string padding enabled)'
    aname="vsLabels"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:outputH5BeamFiles(lables attribute written)'
    CALL h5aclose_f(attr_id, error)
    CALL addH5StringAttribute(dset_id,"vsType","variableWithMesh",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsTimeGroup","time",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsLimits","globalLimits",aspace_id)
!
! Terminate access to the dataset space, still using the scalar identifier
    CALL h5dclose_f(dset_id, error)

! Write time Group
    CALL writeH5TimeGroup(file_id, timegrpname, time, 'outputH5Beam', error)

! Write run info
    CALL writeH5RunInfo(file_id, 'outputH5Beam', error)

! We make the limits
    CALL h5gcreate_f(file_id, limgrpname, group_id, error)
    CALL addH5StringAttribute(group_id,"vsType","limits",aspace_id)
    CALL addH5StringAttribute(group_id,"vsKind","Cartesian",aspace_id)
! end of scalars, need arrays (a vector) for the limits
    CALL h5sclose_f(aspace_id, error)

! And the limits themselves which require non-scalar attributes
! This is the 3D version.
    adims = (/numSpatialDims/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(lower bounds attribute created)'
    ALLOCATE ( limdata(numSpatialDims))
    limdata(1)=-0.5*NX_G*sLengthOfElmX_G
! Particles inhabit a 3D physical space even for 1D simulations.
!    if (numSpatialDims .GT. 1) then
      limdata(2)=-0.5*NY_G*sLengthOfElmY_G
      limdata(3)=0.0
!    end if
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    !Print*,'hdf5_puff:outputH5BeamFiles(upper bounds attribute created)'
    limdata(1)=0.5*NX_G*sLengthOfElmX_G
! Particles inhabit a 3D physical space even for 1D simulations.
!    if (numSpatialDims .GT. 1) then
      limdata(2)=0.5*NY_G*sLengthOfElmY_G
      limdata(3)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G
!    end if
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
! Close the attribute should be done above. 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)
    CALL h5sclose_f(aspace_id, error)    
    CALL h5gclose_f(group_id, error)

    aname="electrons_xSI"
    write(scaleToSIstring, '(E16.9)' ) (DSQRT(lg_G*lc_G)) 
    attr_data_string=("electrons_x*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

! We make another group
    aname="electrons_ySI"
    attr_data_string=("electrons_y*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

! We make another group
    aname="electrons_zSI"
    write(scaleToSIstring, '(E16.9)' ) lc_G
    attr_data_string=("electrons_z*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)!
! Were there an SI version of this, we might be in the right place to use it

    aname="electrons_pxSI"
    write(scaleToSIstring, '(E16.9)' ) sAw_G * m_e * c
    attr_data_string=("electrons_px*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_pySI"
    write(scaleToSIstring, '(E16.9)' ) sAw_G * m_e * c
    attr_data_string=("electrons_py*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_gammaSI"
    write(scaleToSIstring, '(E16.9)' ) sGammaR_G
    attr_data_string=("electrons_gamma*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="slice_nom_lamda"
! Todo: Actually needs to take account of slippage, and needs to identify
! which lamda was used (eg for 2 colour)
    write(scaleToSIstring, '(E16.9)' ) lam_r_G
    attr_data_string=("floor(electrons_zSI/" // scaleToSIstring // ")")
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="phi_lamda"
! Todo: Actually needs to take account of slippage, and needs to identify
! which lamda was used (eg for 2 colour)
    attr_data_string=("(electrons_zSI-(slice_nom_lamda*" // &
     scaleToSIstring // "))*6.283185307179586/" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_numPhysicalParticles"
    write(scaleToSIstring, '(E16.9)' ) npk_bar_G
    attr_data_string=("electrons_weight*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_chargeSI"
    write(scaleToSIstring, '(E16.9)' ) npk_bar_G*q_e
    attr_data_string=("electrons_weight*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

! Todo: write an expression for rms beam sizes
! Todo: write an expression for slice emittance

! Close the file.
    CALL h5fclose_f(file_id, error)

!Close the interface
    CALL h5close_f(error)

!    qOK = .true.            
    goto 2000

!     Error Handler - Error log Subroutine in CIO.f90 line 709
1000 call Error_log('Error in hdf5_puff:outputBeamFiles',tErrorLog_G)
    print*,'Error in hdf5_puff:outputBeamFiles'
2000 continue
  end subroutine outputH5BeamFilesID



!> outputH5BeamFilesSD Output the electron bean macroparticle 
!! 6D phase space coordinates (plus weight) in Puffin.
!! Places all data in a single rank
!! @params unused tArrayE global array (to this rank) 
!! containing particles and layout of data in sV.
!! @params sElX_G, particle x coordinate
!! @params sElY_G, particle y coordinate
!! @params sElZ2_G, particle z2 (displacement from bunch centre)
!! @params iNumberElectrons_G number of electrons (global) on this rank
!! @todo Individual and collective writing to combined file to come
!! For collective write, we want to work out how many particles on 
!! each rank, what the cumulative num electrons is, and then determine
!! the array slice based on that.
!! so instead of 
  subroutine outputH5BeamFilesSD(time, sz_loc, iL, error)
    implicit none
    REAL(kind=WP),intent(in) :: time !< Current time
    REAL(kind=WP),intent(in) :: sz_loc
    integer(kind=ip), intent(in) :: iL  !< lattice element number
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: dset_id       !< Dataset identifier 
    INTEGER(HID_T) :: dspace_id     !< Dataspace identifier in memory
    INTEGER(HID_T) :: filespace     !< Dataspace identifier in file
    INTEGER(HID_T) :: plist_id      !< Property list identifier
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
!    logical, intent(in) :: qSeparate !<May reinstitute this.
    CHARACTER(LEN=9), PARAMETER :: dsetname = "electrons" !< Dataset name
    CHARACTER(LEN=30) :: aname   !< Attribute name
    character(1024_IP) :: filename !< Filename to write - 1024 chars is overkill but...
!    logical, intent(inout) :: qOK
!    INTEGER(HSIZE_T), DIMENSION(1) :: dims = (/iGloNumElectrons_G/) ! Dataset dimensions
    INTEGER(HSIZE_T), DIMENSION(2) :: fdims,dims   !< dims of ptcl dataset (coords*numelecs)
    INTEGER(HSIZE_T), DIMENSION(2) :: doffset!< Offset for write, could be rank dependent
    INTEGER(HSIZE_T), DIMENSION(2) :: dsize  !< Size of hyperslab to write
    INTEGER     ::  rank = 2                 !< Particle Dataset rank
    INTEGER     ::  arank = 1                !< Attribute rank - 1 is vector
    INTEGER(HSIZE_T), DIMENSION(1) :: adims  !< Attribute dims
    INTEGER(HSIZE_T), DIMENSION(1) :: attr_data_int !< For integer attribs (numdims)
    INTEGER     :: numSpatialDims,mpiinfo    !< Attr content, and also num elsewhere  
    INTEGER(kind=IP)     :: startOffset,rankIterator    !< For working out start index  
!assumed 3D sim. May be 1D.
!    TYPE(C_PTR) :: f_ptr
    REAL(kind=WP) :: attr_data_double
    CHARACTER(LEN=100) :: attr_data_string
    CHARACTER(LEN=16) :: scaleToSIstring
    INTEGER(HSIZE_T) :: attr_string_len
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  ! Group name
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  ! Group name
    REAL(kind=WP), ALLOCATABLE :: limdata (:)  ! Data to write
    ! Local vars
    !integer(kind=ip) :: iep
    integer :: error ! Error flag
    mpiinfo=MPI_INFO_NULL

    if (qONED_G) then
      numSpatialDims=1
    else
      numSpatialDims=3
    end if

!   Fortran index of first particle to be written might be '1', however
!   We're interested in the offset from the first step.
    startOffset=0
    if (tProcInfo_G%rank .GT. 0) then
    Do rankIterator=1,tProcInfo_G%rank
      startOffset = startOffset+procelectrons_G(rankIterator+1)
    end do
   
    end if 
!    print*,'Writing electron data on rank ' &
!      // trim(adjustl(IntegerToString(tProcInfo_G%rank))) &
!      // ' Starting at offset ' &
!      // trim(adjustl(IntegerToString(startOffset))) // ' n_elecs=' &
!      // trim(adjustl(IntegerToString(procelectrons_G(1)))) // ' ' &
!      // trim(adjustl(IntegerToString(iNumberElectrons_G)))

    attr_data_int(1)=numSpatialDims
    adims(1)=1 
    adims = (/1/) 
    dims = (/7,iNumberElectrons_G/) ! Dataset dimensions
    fdims = (/7,iGloNumElectrons_G/) ! Dataset dimensions
    doffset=(/0,startOffset/)
    dsize=(/1,iNumberElectrons_G/)
    attr_data_string="electrons_x,electrons_y,electrons_z,electrons_px," // &
      "electrons_py,electrons_gamma,electrons_weight"
    attr_string_len=94

! Prepare filename

    filename = ( trim(adjustl(zFilename_G)) // '_electrons_' // &
                 trim(adjustl(IntegerToString(iCSteps))) // '.h5' )


    CALL h5open_f(error)
    CALL h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, error)
!      Print*,'hdf5_puff:outputH5BeamSD(property created)'
!      Print*,error
      CALL h5pset_fapl_mpio_f(plist_id, tProcInfo_G%comm, mpiinfo, error)
!      Print*,'hdf5_puff:outputH5BeamSD(property set up)'
!      Print*,error
      CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error, access_prp = plist_id)
!     Print*,'hdf5_puff:outputH5BeamSD(file created)'
!     Print*,error
     CALL h5pclose_f(plist_id, error)
!     Print*,'hdf5_puff:outputH5BeamSD(property closed)'
!     Print*,error
     CALL h5screate_simple_f(rank, fdims, filespace, error)
!     Print*,'hdf5_puff:outputH5BeamSD(filespace created)'
     CALL h5dcreate_f(file_id, dsetname, H5T_NATIVE_DOUBLE, filespace, &
       dset_id, error)
!     Print*,'hdf5_puff:outputH5BeamSD(dataset created)'
!     Print*,error
     CALL h5sclose_f(filespace, error)
!     Print*,'hdf5_puff:outputH5BeamSD(filespace closed)'
!     Print*,error
! Select hyperslab in the file.


!      if (procelectrons_G(1).GT.0) then
! for the corresponding space on disk
        CALL h5screate_simple_f(rank, dsize, dspace_id, error)
        if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(dspace_id, error)

!        Print*,'hdf5_puff:outputH5BeamFilesSD(memory dataspace allocated)'
!        Print*,error
        CALL h5dget_space_f(dset_id, filespace, error)
        CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
        if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
!        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
!          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!      else
! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
!        CALL h5sselect_none_f(filespace,error)
!        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
!          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!        CALL h5sselect_none_f(dspace_id,error)
!      end if
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, error) 
!      CALL h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_INDEPENDENT_F, error)
      CALL h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F, error)
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
!         sElX_G((startOffset+1):(startOffset+procelectrons_G(1))), dsize, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
         sElX_G, dsize, error, &
         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(write done)'
      CALL h5sclose_f(filespace, error)
!      Print*,'hdf5_puff:outputH5BeamSD(x space closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!      Defer this until all coordinates/components are written
!      CALL h5sclose_f(dspace_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(hyperslab space closed)'
!      Print*,error
      
! repeat for some next y dataset


    doffset=(/1,startOffset/)

!if (procelectrons_G(1).GT.0) then
! for the corresponding space on disk

  CALL h5dget_space_f(dset_id, filespace, error)
  CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
!        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
!          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!else
! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
  if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
!        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
!          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!end if




    !CALL H5Dget_space_f(dset_id, filespace, error)
    !CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
    !   dsize, error)
       
       
       
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
       sElY_G, dsize, error, &
       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(y space closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

!
! repeat for some next z dataset
    doffset=(/2,startOffset/)
    
!    if (procelectrons_G(1).GT.0) then
    ! for the corresponding space on disk

      CALL h5dget_space_f(dset_id, filespace, error)
      CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    else
    ! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
      if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    end if
    
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
       sElZ2_G, dsize, error, &
       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(z2 space closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

! repeat for some next px dataset
    doffset=(/3,startOffset/)
    
!    if (procelectrons_G(1).GT.0) then
    ! for the corresponding space on disk

      CALL h5dget_space_f(dset_id, filespace, error)
      CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    else
    ! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
      if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
     
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    end if

!    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
!       sElPX_G((startOffset+1):(startOffset+procelectrons_G(1))), dsize, error, &
!       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
       sElPX_G, dsize, error, &
       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(px space closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

! repeat for some next py dataset
    doffset=(/4,startOffset/)

!    if (procelectrons_G(1).GT.0) then
    ! for the corresponding space on disk

      CALL h5dget_space_f(dset_id, filespace, error)
      CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    else
    ! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
      if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    end if
    
!    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
!       sElPY_G((startOffset+1):(startOffset+procelectrons_G(1))), dsize, error, &
!       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
       sElPY_G, dsize, error, &
       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(py space closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 

! repeat for some next gamma dataset (actually beta*gamma)
    doffset=(/5,startOffset/)

!    if (procelectrons_G(1).GT.0) then
    ! for the corresponding space on disk

      CALL h5dget_space_f(dset_id, filespace, error)
      CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    else
    ! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
      if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    end if
    
!    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
!       sElgam_G((startOffset+1):(startOffset+procelectrons_G(1))), dsize, error, &
!       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
       sElgam_G, dsize, error, &
       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(pz2 space closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 
!
! 
! put Chi in the file, slightly redundant as charge on a macroparticle
! doesn't increase or decrease through the simulation. But does make
! Everything self contained. Perhaps we use in future a funky h5 technique
! to point this column at a separate file which holds the data, reducing 
! the size of this column from every written file.
    doffset=(/6,startOffset/)

!    if (procelectrons_G(1).GT.0) then
    ! for the corresponding space on disk

      CALL h5dget_space_f(dset_id, filespace, error)
      CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dsize, error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    else
    ! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
      if (procelectrons_G(1) <= 0) CALL h5sselect_none_f(filespace,error)
    !        Print*,trim(adjustl(IntegerToString(error))) // " selecting no particles on rank" &
    !          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!    end if
    
!    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
!       s_chi_bar_G((startOffset+1):(startOffset+procelectrons_G(1))), dsize, error, &
!       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, &
       s_chi_bar_G, dsize, error, &
       xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5BeamSD(charge dataspace closed) rank: ' // &
!         trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
! was       dspace_id, filespace)
    CALL h5sclose_f(filespace, error) 
! Terminate access to the data space.
!
    CALL h5sclose_f(dspace_id, error)  
!
! ATTRIBUTES FOR PARTICLE DATASET
!
! simple dataset for array of vals
!    CALL h5screate_simple_f(arank, adims, aspace_id, error)

! scalar dataset for simpler values
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!
! Create datatype for the attribute.
!
    CALL h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
!    CALL h5tset_size_f(atype_id, attrlen, error)
    !
! Create dataset attribute.
!
    aname = "vsNumSpatialDims"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
! Write the attribute data.
    CALL h5awrite_f(attr_id, atype_id, numSpatialDims, adims, error) !
! Close the attribute.
    CALL h5aclose_f(attr_id, error)
! next attribute
    aname="numSpatialDims"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, numSpatialDims, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)

! integers done, move onto floats
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
!    aname="time"
!    attr_data_double=time
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
! then
    aname="mass"
!    attr_data_double=9.10938356E-31
    attr_data_double=m_e
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="charge"
!    attr_data_double=1.602176487E-19
    attr_data_double=q_e
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(charge written)'
    aname="numTotalPhysicalParticles"
    attr_data_double=npk_bar_G*q_e
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    
    
    call writeCommonAtts(dset_id, time, sz_loc, iL, aspace_id)
!    aname="zbarInter"
!    attr_data_double=time !real(iCSteps,kind=wp)*sStepSize*lg_G
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
!    aname="zInter"
!    attr_data_double=time*lg_G !real(iCSteps,kind=wp)*sStepSize*lg_G
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
!
!    call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!    call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)


    aname="gainLength"
    attr_data_double=lg_G
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="cooperationLength"
    attr_data_double=lc_G
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)
    CALL h5sclose_f(aspace_id, error)
    CALL h5pclose_f(plist_id, error)
!    Print*,'hdf5_puff:outputH5BeamSD(propertylist closed)'
!    Print*,error
      CALL h5dclose_f(dset_id, error)
!      Print*,'hdf5_puff:outputH5BeamSD(dataset closed)'
!      Print*,error

      CALL h5fclose_f(file_id, error)
!      Print*,'hdf5_puff:outputH5BeamSD(file closed)'
!      Print*,error


!!!
!Close and reopen serial to write the other stuff.
!!!
      if (tProcInfo_G%qRoot) then 
      CALL h5fopen_f(filename, H5F_ACC_RDWR_F, file_id, error)
!      Print*,'hdf5_puff:outputH5BeamSD(file reopened in serial)'
!      Print*,error
      CALL h5dopen_f (file_id, dsetname, dset_id, error)
!      Print*,'hdf5_puff:outputH5BeamSD(dataset reopened in serial)'
!      Print*,error

    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
! then text attributes
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(string padding enabled)'
    aname="vsLabels"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:outputH5BeamFiles(lables attribute written)'
    CALL h5aclose_f(attr_id, error)
    CALL addH5StringAttribute(dset_id,"vsType","variableWithMesh",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsTimeGroup","time",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsLimits","globalLimits",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsAxisLabels","xbar,ybar,z2bar",aspace_id)
!
! Terminate access to the dataset space, still using the scalar identifier
    CALL h5dclose_f(dset_id, error)


! Write time Group
    CALL writeH5TimeGroup(file_id, timegrpname, time, 'outputH5Beam', error)

! Write run info
    CALL writeH5RunInfo(file_id, 'outputH5Beam', error)

! We make the limits
    CALL h5gcreate_f(file_id, limgrpname, group_id, error)
    CALL addH5StringAttribute(group_id,"vsType","limits",aspace_id)
    CALL addH5StringAttribute(group_id,"vsKind","Cartesian",aspace_id)
! end of scalars, need arrays (a vector) for the limits
    CALL h5sclose_f(aspace_id, error)

! And the limits themselves which require non-scalar attributes
! This is the 3D version.
    adims = (/numSpatialDims/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(lower bounds attribute created)'
    ALLOCATE ( limdata(numSpatialDims))
    limdata(1)=-0.5*NX_G*sLengthOfElmX_G
! Particles inhabit a 3D physical space even for 1D simulations.
!    if (numSpatialDims .GT. 1) then
      limdata(2)=-0.5*NY_G*sLengthOfElmY_G
      limdata(3)=0.0
!    end if
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(upper bounds attribute created)'
    limdata(1)=0.5*NX_G*sLengthOfElmX_G
! Particles inhabit a 3D physical space even for 1D simulations.
!    if (numSpatialDims .GT. 1) then
      limdata(2)=0.5*NY_G*sLengthOfElmY_G
      limdata(3)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G
!    end if
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
! Close the attribute should be done above. 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)
    CALL h5sclose_f(aspace_id, error)    
    CALL h5gclose_f(group_id, error)

    aname="electrons_xSI"
    write(scaleToSIstring, '(E16.9)' ) (DSQRT(lg_G*lc_G)) 
    attr_data_string=("electrons_x*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

! We make another group
    aname="electrons_ySI"
    attr_data_string=("electrons_y*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

! We make another group
    aname="electrons_zSI"
    write(scaleToSIstring, '(E16.9)' ) lc_G
    attr_data_string=("electrons_z*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)!
! Were there an SI version of this, we might be in the right place to use it

    aname="electrons_pxSI"
    write(scaleToSIstring, '(E16.9)' ) sAw_G * m_e * c
    attr_data_string=("electrons_px*" // scaleToSIstring)
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_pySI"
    write(scaleToSIstring, '(E16.9)' ) sAw_G * m_e * c
    attr_data_string=("electrons_py*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_gammaSI"
    write(scaleToSIstring, '(E16.9)' ) sGammaR_G
    attr_data_string=("electrons_gamma*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="slice_nom_lamda"
! Todo: Actually needs to take account of slippage, and needs to identify
! which lamda was used (eg for 2 colour)
    write(scaleToSIstring, '(E16.9)' ) lam_r_G
    attr_data_string=("floor(electrons_zSI/" // scaleToSIstring // ")")
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="phi_lamda"
! Todo: Actually needs to take account of slippage, and needs to identify
! which lamda was used (eg for 2 colour)
    attr_data_string=("(electrons_zSI-(slice_nom_lamda*" // &
     scaleToSIstring // "))*6.283185307179586/" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_numPhysicalParticles"
    write(scaleToSIstring, '(E16.9)' ) npk_bar_G
    attr_data_string=("electrons_weight*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

    aname="electrons_chargeSI"
    write(scaleToSIstring, '(E16.9)' ) npk_bar_G*q_e
    attr_data_string=("electrons_weight*" // scaleToSIstring)
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)

! NOT Todo: write an expression for rms beam sizes - available through
! Data reduction operator.
! Todo: write an expression for slice emittance

! Close the file.
    CALL h5fclose_f(file_id, error)
    end if
!Close the interface
    CALL h5close_f(error)

!    qOK = .true.            
    goto 2000

!     Error Handler - Error log Subroutine in CIO.f90 line 709
1000 call Error_log('Error in hdf5_puff:outputBeamFiles',tErrorLog_G)
    print*,'Error in hdf5_puff:outputBeamFiles'
2000 continue
  end subroutine outputH5BeamFilesSD






!> outputH5Field3DID is for writing the full field output.
!! This version dumps on each rank separately.
  subroutine outputH5Field3DID(time, sz_loc, iL, error, nlonglength, dsetname, rawdata, nlo, nhi, chkactiveflag)
    implicit none
    REAL(kind=WP), intent(in) :: time, sz_loc, rawdata(:) !< The data to write
    integer(kind=ip), intent(in) :: iL
    CHARACTER(*), intent(in) :: dsetname !< Dataset name
    INTEGER(kind=IP), intent(in) :: nlonglength !<number of cells in z in this section
    INTEGER(kind=IP), intent(in) :: nlo,nhi !< cell range in z in this raw data selection
    LOGICAL, intent(in) :: chkactiveflag !< flag determines whether to test for the entire field on every rank
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: dset_id       !< Dataset identifier 
    INTEGER(HID_T) :: dspace_id     !< Dataspace identifier in memory
    INTEGER(HID_T) :: filespace     !< Dataspace identifier in file
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
! may yet need this, but field data is not separated amongst cores
!    logical, intent(in) :: qSeparate
!    CHARACTER(LEN=5), PARAMETER :: dsetname = "aperp"     ! Dataset name
    CHARACTER(LEN=16) :: aname   ! Attribute name
!    character(1024_IP), intent(in) :: zDFName
    character(64_IP) :: filename
    INTEGER(HSIZE_T), DIMENSION(3) :: dims !<no longer includes component
! Data as component*reducedNX*reducedNY*reducedNZ2
! Not described as a parameter, so can prob modify 
! for single component (rank 3 data) like charge
    INTEGER     ::   rank = 3               !< Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: adims !< Attribute dims
    REAL(kind=WP) :: attr_data_double       !< holder of attribute double data
    REAL(kind=WP), DIMENSION(3) :: ub       !< holder of attribute double data
    REAL(kind=WP), DIMENSION(3) :: lb       !< holder of attribute double data
    CHARACTER(LEN=100) :: attr_data_string  !< holder of attribute strings 
    INTEGER(HSIZE_T) :: attr_string_len     !< length of attribute strings
    INTEGER(kind=IP) :: numSpatialDims      !< Attr content,  
    INTEGER     ::  arank = 1               !< Attribute Dataset rank (1: vector)
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  !< Name of time group
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  !< Name of limits grp
    CHARACTER(LEN=10), PARAMETER :: meshScaledGrpname = "meshScaled" !< Name of mesh grp
    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshSI"  !< Dummy scaled mesh grp name
    REAL(kind=WP), ALLOCATABLE :: limdata (:)  !< Data to write (diff for 1D and 3D)
    INTEGER(kind=IP), ALLOCATABLE :: numcelldata (:)  !< Mesh info for uniform grid
    ! Local vars
    integer :: error !< Error flag

! signature: nlonglength, dsetname, data, nlo, nhi, chkactiveflag
! tlflen, 'aperp_front_real', fr_rfield, [ffs,ffe], .false.
! tlflen, 'aperp_front_imag', fr_ifield, [ffs,ffe], .false.
! mainlen, 'aperp_active_real', ac_rfield, [fz2,ez2], .true.
! mainlen, 'aperp_active_imag', ac_ifield, [fz2,ez2], .true.
! tlelen, 'aperp_back_real', bk_rfield, [ees,eee], .false.
! tlelen, 'aperp_back_imag', bk_ifield, [ees,eee], .false.
! final argument  checks for all active field on single root node ... 
! should say if qUnique or rank=0...

    if (qUnique .OR. (tProcInfo_G%qRoot)) then
    if (nlonglength.GT.0) then
    if (qONED_G) then
      numSpatialDims=1
      dims = (/1,1,nlonglength/) ! Dataset dimensions
    else
      numSpatialDims=3
      dims = (/nx_g,ny_g,nlonglength/) ! Dataset dimensions
    end if
!    print *,IntegerToString(size(fr_rfield)) // " vs " //trim(adjustl(IntegerToString(Nx_g*ny_g*nlonglength)))

!    Print*,('Spatialdims: ' // trim(IntegerToString(numSpatialDims)))
    filename = (trim(adjustl(zFilename_G)) // '_' // trim(adjustl(dsetname)) &
        // '_' // trim(adjustl(IntegerToString(tProcInfo_G%Rank))) &
        // '_' // trim(adjustl(IntegerToString(iStep))) // '.h5' )
      CALL h5open_f(error)
      CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error)
      CALL h5screate_simple_f(rank, dims, filespace, error)
!      Print*,'hdf5_puff:outputH5FieldID(filespace created)'
      CALL h5dcreate_f(file_id, dsetname, H5T_NATIVE_DOUBLE, filespace, &
       dset_id, error)
!      Print*,'hdf5_puff:outputH5FieldID(dataset created)'
!      Print*,error
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error)
!      Print*,'hdf5_puff:outputH5FieldID(write done)'
!      Print*,error
      CALL h5sclose_f(filespace, error)
!      Print*,'hdf5_puff:outputH5FieldID(filespace closed)'
!      Print*,error
      CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!      Print*,'hdf5_puff:outputH5Field(scalar space created)'
!      CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)


      call writeCommonAtts(dset_id, time, sz_loc, iL, aspace_id)

!      CALL addH5FloatAttribute(dset_id, "time", time,aspace_id)
!      CALL addH5FloatAttribute(dset_id, "zbarInter", time,aspace_id)
!      CALL addH5FloatAttribute(dset_id, "zInter", time*lg_G,aspace_id)
!
!      call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)

!      CALL addH5FloatAttribute(dset_id, z, iStep*,aspace_id)
!      aname="time"
!      attr_data_double=time
!      CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!      CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!      CALL h5aclose_f(attr_id, error)
!      CALL h5tclose_f(atype_id, error)
      CALL addH5StringAttribute(dset_id,"vsLabels","aperp_front_realfield",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsType","variable",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsCentering","nodal",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMajorF",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsLimits",limgrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsMesh",meshScaledGrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsAxisLabels","xbar,ybar,z2bar",aspace_id)
      CALL h5dclose_f(dset_id, error)	  
! Time Group 
      CALL writeH5TimeGroup(file_id, timegrpname, time, &
	     'outH5Field3D', error)
      CALL writeH5RunInfo(file_id, 'outH5Field3D', error)
      lb(1)=-0.5*NX_G*sLengthOfElmX_G
      lb(2)=-0.5*NY_G*sLengthOfElmY_G
      lb(3)=(nlo-1)*sLengthOfElmZ2_G
      ub(1)=0.5*NX_G*sLengthOfElmX_G
      ub(2)=0.5*NY_G*sLengthOfElmY_G
      ub(3)=nhi*sLengthOfElmZ2_G
      CALL write3DlimGrp(file_id,limgrpname,lb,ub)
      CALL write3DuniformMesh(file_id,meshScaledGrpname,lb,ub,(/nx_g,ny_g,nlonglength/))
      CALL h5fclose_f(file_id, error)
    end if
   end if
  end subroutine outputH5Field3DID



!> outputH5Field3DSD is for writing the full field output.
!! This version dumps one single file, but writes individually rather than collectively
  subroutine outputH5Field3DSD(time, sz_loc, iL, error, nlonglength, rawdata, nlo, nhi, component, createNewFlag, chkactiveflag)
    implicit none
    REAL(kind=WP), intent(in) :: time, sz_loc, rawdata(:) !< The data to write
    integer(kind=ip), intent(in) :: iL
    INTEGER(kind=IP), intent(in) :: nlonglength !<number of cells in z in this section
    INTEGER(kind=IP), intent(in) :: nlo,nhi !< cell range in z in this raw data selection
    INTEGER(kind=IP), intent(in) :: component, createNewFlag !< cell range in 4th dim in this raw data selection
    LOGICAL, intent(in) :: chkactiveflag !< flag determines whether to test for the entire field on every rank
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: dset_id       !< Dataset identifier 
    INTEGER(HID_T) :: dspace_id     !< Dataspace identifier in memory
    INTEGER(HID_T) :: filespace     !< Dataspace identifier in file
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
    INTEGER(HID_T) :: plist_id      !< Property list id.

! may yet need this, but field data is not separated amongst cores
!    logical, intent(in) :: qSeparate
    CHARACTER(LEN=5), PARAMETER :: dsetname = "aperp"     ! Dataset name
    CHARACTER(LEN=16) :: aname   ! Attribute name
!    character(1024_IP), intent(in) :: zDFName
    character(64_IP) :: filename
    INTEGER(HSIZE_T), DIMENSION(4) :: fdims,dims !<no longer includes component
    INTEGER(HSIZE_T), DIMENSION(4) :: doffset,dsize,stride !<no longer includes component
! Data as component*reducedNX*reducedNY*reducedNZ2
! Not described as a parameter, so can prob modify 
! for single component (rank 3 data) like charge
    INTEGER     ::   rank = 4               !< Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: adims !< Attribute dims
    REAL(kind=WP) :: attr_data_double       !< holder of attribute double data
    REAL(kind=WP), DIMENSION(3) :: ub       !< holder of attribute double data
    REAL(kind=WP), DIMENSION(3) :: lb       !< holder of attribute double data
    CHARACTER(LEN=100) :: attr_data_string  !< holder of attribute strings 
    INTEGER(HSIZE_T) :: attr_string_len     !< length of attribute strings
    INTEGER(kind=IP) :: numSpatialDims,mpiinfo      !< Attr content,  
    INTEGER     ::  arank = 1               !< Attribute Dataset rank (1: vector)
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  !< Name of time group
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  !< Name of limits grp
    CHARACTER(LEN=10), PARAMETER :: meshScaledGrpname = "meshScaled" !< Name of mesh grp
    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshSI"  !< Dummy scaled mesh grp name
    REAL(kind=WP), ALLOCATABLE :: limdata (:)  !< Data to write (diff for 1D and 3D)
    INTEGER(kind=IP), ALLOCATABLE :: numcelldata (:)  !< Mesh info for uniform grid
    ! Local vars
    integer :: error !< Error flag

! signature: nlonglength, dsetname, data, nlo, nhi, chkactiveflag
! tlflen, 'aperp_front_real', fr_rfield, [ffs,ffe], .false.
! tlflen, 'aperp_front_imag', fr_ifield, [ffs,ffe], .false.
! mainlen, 'aperp_active_real', ac_rfield, [fz2,ez2], .true.
! mainlen, 'aperp_active_imag', ac_ifield, [fz2,ez2], .true.
! tlelen, 'aperp_back_real', bk_rfield, [ees,eee], .false.
! tlelen, 'aperp_back_imag', bk_ifield, [ees,eee], .false.
! final argument  checks for all active field on single root node ... 
! should say if qUnique or rank=0...
    mpiinfo=MPI_INFO_NULL
    if (qUnique .OR. (tProcInfo_G%qRoot)) then
    if (qONED_G) then
      numSpatialDims=1
      dims = (/1,1,nlonglength,1/) ! Dataset dimensions
      fdims = (/2,2,NZ2_G,2/) ! Dataset dimensions
      doffset = (/0,0,(nlo-1),component/)
      dsize = (/1,1,nhi-nlo+1,1/)
    else
      numSpatialDims=3
      dims = (/nx_g,ny_g,nlonglength,1/) ! Dataset dimensions
      fdims = (/nx_g,ny_g,NZ2_G,2/) ! Dataset dimensions
      doffset = (/0,0,(nlo-1),component/)
!      dsize = (/nx_g,ny_g,nhi-nlo+1,1/)
      dsize = (/nx_g,ny_g,nlonglength,1/)
    end if
!    print *,IntegerToString(size(rawdata)) // " vs " // &
!      trim(adjustl(IntegerToString(Nx_g*ny_g*nlonglength))) // &
!      "   nlo-1 : " // trim(adjustl(IntegerToString(nlo-1))) // &
!      "   nlo+nlonglength-1 : " // trim(adjustl(IntegerToString(nlo+nlonglength-1)))
!! repeat for some next y dataset
!    doffset=(/1,0/)
!    CALL H5Dget_space_f(dset_id, filespace, error)
!    CALL h5sselect_hyperslab_f(filespace, H5S_SELECT_SET_F, doffset, &
!       dsize, error)
!    CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sElY_G, dims, error, &
!       file_space_id = filespace, mem_space_id = dspace_id)
!! was       dspace_id, filespace)
!    CALL h5sclose_f(filespace, error) 


!    Print*,('Spatialdims: ' // trim(IntegerToString(numSpatialDims)))
    filename = (trim(adjustl(zFilename_G)) // '_' // trim(adjustl(dsetname)) &
        // '_' // trim(adjustl(IntegerToString(iCSteps))) // '.h5' )
      CALL h5open_f(error)
      CALL h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(property created)'
!      Print*,error
      CALL h5pset_fapl_mpio_f(plist_id, tProcInfo_G%comm, mpiinfo, error)
!      Print*,'hdf5_puff:outputH5FieldSD(property set up)'
!      Print*,error
      if (createNewFlag .EQ. 1) then
        CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error, access_prp = plist_id)
!      Print*,'hdf5_puff:outputH5FieldSD(file created)'
!      Print*,error
      CALL h5pclose_f(plist_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(property closed)'
!      Print*,error
      CALL h5screate_simple_f(rank, fdims, filespace, error)
!      Print*,'hdf5_puff:outputH5FieldSD(filespace created)'
      CALL h5dcreate_f(file_id, dsetname, H5T_NATIVE_DOUBLE, filespace, &
       dset_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(dataset created)'
!      Print*,error
      CALL h5sclose_f(filespace, error)
!      Print*,'hdf5_puff:outputH5FieldSD(filespace closed)'
!      Print*,error
      else  ! not creating a new file, just adding data to an existing one.
        CALL h5pset_fapl_mpio_f(plist_id, tProcInfo_G%comm, mpiinfo, error)
        CALL h5fopen_f(filename, H5F_ACC_RDWR_F, file_id, error, access_prp = plist_id)
!        Print*,'hdf5_puff:outputH5FieldSD(file reopened in parallel)'
!        Print*,error
        CALL h5dopen_f (file_id, dsetname, dset_id, error)
!        Print*,'hdf5_puff:outputH5FieldSD(dataset reopened in parallel)'
!        Print*,error
        CALL h5pclose_f(plist_id, error)
      end if
      CALL h5screate_simple_f(rank, dims, dspace_id, error)
 ! For the space in memory
      if (nlonglength.GT.0) then
! for the corresponding space on disk
        CALL h5dget_space_f(dset_id, filespace, error)
        CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dims, error)
!        Print*,trim(adjustl(IntegerToString(error))) // " selecting slab on rank" &
!          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
      else
! all ranks must participate, so select no space to write when dealing with ranks which hold no data for this field fr_real, etc
        CALL h5sselect_none_f(filespace,error)
!        Print*,trim(adjustl(IntegerToString(error))) // " selecting empty slab on rank" &
!          //   trim(adjustl(IntegerToString(tProcInfo_G%Rank)))
!        CALL h5sselect_none_f(dspace_id,error)
      end if

      
      CALL h5pcreate_f(H5P_DATASET_XFER_F, plist_id, error) 
      CALL h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_INDEPENDENT_F, error)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      Print*,'hdf5_puff:outputH5FieldSD(write done)'
!      Print*,error

      ! ABORTIVE ATTEMPT TO WRITE NODAL DATA, when really it's nodal in z2 but 1D (so
      !shouldn't matter if zonal or nodal) in x,y.
!        if (qONED_G) then
!      if (nlonglength.GT.0) then
!      doffset = (/0,1,(nlo-1),component/)
!        CALL h5dget_space_f(dset_id, filespace, error)
!       CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dims, error)
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      doffset = (/1,0,(nlo-1),component/)
!        CALL h5dget_space_f(dset_id, filespace, error)
!        CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dims, error)
!     CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!      doffset = (/1,1,(nlo-1),component/)
!        CALL h5dget_space_f(dset_id, filespace, error)
!        CALL h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, dims, error)
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!     else
!        CALL h5sselect_none_f(filespace,error)
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!        CALL h5sselect_none_f(filespace,error)
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!        CALL h5sselect_none_f(filespace,error)
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
!         xfer_prp = plist_id, file_space_id = filespace, mem_space_id = dspace_id)
!     end if
!     end if
       CALL h5sclose_f(filespace, error)
!      Print*,'hdf5_puff:outputH5FieldSD(file space closed)'
!      Print*,error
      CALL h5sclose_f(dspace_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(hyperslab space closed)'
!      Print*,error
      CALL h5pclose_f(plist_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(propertylist closed)'
!      Print*,error
      CALL h5dclose_f(dset_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(dataset closed)'
!      Print*,error
      CALL h5fclose_f(file_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(file closed)'
!      Print*,error
! end of parallel write stuff

! add stuff just on rank 0
      if (createNewFlag .EQ. 1) then

      if (tProcInfo_G%qRoot) then 
      CALL h5fopen_f(filename, H5F_ACC_RDWR_F, file_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(file reopened in serial)'
!      Print*,error
     CALL h5dopen_f (file_id, dsetname, dset_id, error)
!      Print*,'hdf5_puff:outputH5FieldSD(dataset reopened in serial)'
!      Print*,error
!      CALL h5dget_space_f(dset_id, filespace, error)
      CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!      Print*,'hdf5_puff:outputH5Field3DSD(scalar space created)'
    CALL h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
!    CALL h5tset_size_f(atype_id, attrlen, error)
!
! Create dataset integer attributes.
! Always ndim=3 even if 1D as 1 cell in both transverse dims but same
! postprocessing should work, and make possible to display vs particles
!
!
    aname = "vsNumSpatialDims"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
! Write the attribute data.
    CALL h5awrite_f(attr_id, atype_id, 3, adims, error) !
! Close the attribute.
    CALL h5aclose_f(attr_id, error)
! next attribute
    aname="numSpatialDims"
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, 3, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)

! Create dataset floating point attributes.

    call writeCommonAtts(dset_id, time, sz_loc, iL, aspace_id)

!     CALL addH5FloatAttribute(dset_id, "time", time,aspace_id)
!     CALL addH5FloatAttribute(dset_id, "zbarInter", time, aspace_id)
!     CALL addH5FloatAttribute(dset_id, "zInter", time*lg_G, aspace_id)
!
!     call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)

!    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
!      aname="time"
!      attr_data_double=time
!      CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!      CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!      CALL h5aclose_f(attr_id, error)
!      CALL h5tclose_f(atype_id, error)
      CALL addH5StringAttribute(dset_id,"vsLabels","aperp_real, aperp_imaginary",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsType","variable",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsCentering","nodal",aspace_id)
      if (qoned_g) then
         CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMinorF",aspace_id)
      else
         CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMajorF",aspace_id)
      end if 
      CALL addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsLimits",limgrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsMesh",meshScaledGrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsAxisLabels","xbar,ybar,z2bar",aspace_id)
      CALL h5dclose_f(dset_id, error)	  
! Time Group 
      CALL writeH5TimeGroup(file_id, timegrpname, time, &
	     'outH5Field3D', error)
      CALL writeH5RunInfo(file_id, 'outH5Field3D', error)
      lb(1)=-0.5*NX_G*sLengthOfElmX_G
      lb(2)=-0.5*NY_G*sLengthOfElmY_G
      lb(3)=0.0_WP*sLengthOfElmZ2_G
      ub(1)=0.5*NX_G*sLengthOfElmX_G
      ub(2)=0.5*NY_G*sLengthOfElmY_G
      ub(3)=NZ2_G*sLengthOfElmZ2_G
      CALL write3DlimGrp(file_id,limgrpname,lb,ub)
    if (qONED_G) then
      CALL write3DuniformMesh(file_id,meshScaledGrpname,lb,ub,(/1,1,NZ2_G-1/))
    else
      CALL write3DuniformMesh(file_id,meshScaledGrpname,lb,ub,(/nx_g-1,ny_g-1,NZ2_G-1/))
    endif
      aname="intensityScaled"
      attr_data_string="sqr(aperp_real)+sqr(aperp_imaginary)"
      attr_string_len=len(trim(adjustl(attr_data_string)))
      CALL addH5derivedVariable(file_id,aname,attr_data_string,error)
      CALL h5fclose_f(file_id, error)
      end if
   end if
   end if
  end subroutine outputH5Field3DSD


!> outputH5Field3DSD is for writing the full field output.
!! This version dumps one single file, but writes individually rather than collectively

  subroutine outputH5Field1D2CompSD(time, sz_loc, iL, error, nlonglength, rawdata, nlo, &
                                  nhi, component, createNewFlag, chkactiveflag)


    implicit none


    real(kind=wp), intent(in) :: time, sz_loc, rawdata(:)  !< The data to write
    integer(kind=ip), intent(in) :: iL
    integer(kind=ip), intent(in) :: nlonglength    !<number of cells in z in this section
    integer(kind=ip), intent(in) :: nlo,nhi        !< cell range in z in this raw data selection
    integer(kind=ip), intent(in) :: component, createNewFlag !< cell range in 4th dim in this raw data selection
    LOGICAL, intent(in) :: chkactiveflag   !< flag determines whether to test for the entire field on every rank
    
    
    integer(HID_T) :: file_id       !< File identifier
    integer(HID_T) :: dset_id       !< Dataset identifier 
    integer(HID_T) :: dspace_id     !< Dataspace identifier in memory
    integer(HID_T) :: filespace     !< Dataspace identifier in file
    integer(HID_T) :: attr_id       !< Attribute identifier
    integer(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    integer(HID_T) :: atype_id      !< Attribute Data type identifier
    integer(HID_T) :: group_id      !< Group identifier
    integer(HID_T) :: plist_id      !< Property list id.

! may yet need this, but field data is not separated amongst cores
!    logical, intent(in) :: qSeparate

    character(len=5), parameter :: dsetname = "aperp"     ! Dataset name
    character(len=16) :: aname   ! Attribute name
!    character(1024_IP), intent(in) :: zDFName
    character(64_IP) :: filename
    integer(HSIZE_T), dimension(2) :: fdims,dims !<no longer includes component
    integer(HSIZE_T), dimension(2) :: doffset,dsize !<no longer includes component

! Data as component*reducedNX*reducedNY*reducedNZ2
! Not described as a parameter, so can prob modify 
! for single component (rank 3 data) like charge

    integer     ::   rank = 2               !< Dataset rank
    integer(HSIZE_T), dimension(1) :: adims !< Attribute dims
    real(kind=wp) :: attr_data_double       !< holder of attribute double data
    real(kind=wp) :: ub       !< holder of attribute double data
    real(kind=wp) :: lb       !< holder of attribute double data
    character(len=100) :: attr_data_string  !< holder of attribute strings 
    integer(HSIZE_T) :: attr_string_len     !< length of attribute strings
    integer(kind=ip) :: numSpatialDims,mpiinfo      !< Attr content,  
    integer     ::  arank = 1               !< Attribute Dataset rank (1: vector)
    character(len=4),  parameter :: timegrpname = "time"  !< Name of time group
    character(len=12), parameter :: limgrpname = "globalLimits"  !< Name of limits grp
    character(len=10), parameter :: meshScaledGrpname = "meshScaled" !< Name of mesh grp
    character(len=6),  parameter :: meshSIGrpname = "meshSI"  !< Dummy scaled mesh grp name
    real(kind=wp),  allocatable  :: limdata (:)  !< Data to write (diff for 1D and 3D)
    integer(kind=ip), allocatable :: numcelldata (:)  !< Mesh info for uniform grid
    ! Local vars
    integer :: error !< Error flag

! signature: nlonglength, dsetname, data, nlo, nhi, chkactiveflag
! tlflen, 'aperp_front_real', fr_rfield, [ffs,ffe], .false.
! tlflen, 'aperp_front_imag', fr_ifield, [ffs,ffe], .false.
! mainlen, 'aperp_active_real', ac_rfield, [fz2,ez2], .true.
! mainlen, 'aperp_active_imag', ac_ifield, [fz2,ez2], .true.
! tlelen, 'aperp_back_real', bk_rfield, [ees,eee], .false.
! tlelen, 'aperp_back_imag', bk_ifield, [ees,eee], .false.
! final argument  checks for all active field on single root node ... 
! should say if qUnique or rank=0...

    mpiinfo=MPI_INFO_NULL
    
    if (qUnique .OR. (tProcInfo_G%qRoot)) then

      if (qONED_G) then

        numSpatialDims=1
        dims = (/nlonglength,1/) ! Dataset dimensions (portion of single comp.)
        fdims = (/NZ2_G,2/)      ! File Dataset dimensions
        doffset = (/(nlo-1),component/)
        dsize = (/nhi-nlo+1,1/)

      else   ! if not 1D (WE SHOULD NOT BE HERE)
!        numSpatialDims=3
        print *,"***Routine is set up for 1D data, but you do not have 1D data" 
!        dims = (/nx_g,ny_g,nlonglength,1/) ! Dataset dimensions
!        fdims = (/nx_g,ny_g,NZ2_G,2/) ! Dataset dimensions
!        doffset = (/0,0,(nlo-1),component/)
!        dsize = (/nx_g,ny_g,nhi-nlo+1,1/)
!        dsize = (/nx_g,ny_g,nlonglength,1/)

      end if

!    Print*,('Spatialdims: ' // trim(IntegerToString(numSpatialDims)))
      filename = (trim(adjustl(zFilename_G)) // '_' // trim(adjustl(dsetname)) &
               // '_' // trim(adjustl(IntegerToString(iCSteps))) // '.h5' )

      call h5open_f(error)

!          Create property

      call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, error)

!          Set property

      call h5pset_fapl_mpio_f(plist_id, tProcInfo_G%comm, mpiinfo, error)

      if (createNewFlag == 1) then
        
!                  Create file  

        call h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error, access_prp = plist_id)

        call h5pclose_f(plist_id, error)  ! Close property

        call h5screate_simple_f(rank, fdims, filespace, error)  ! Create filespace

        call h5dcreate_f(file_id, dsetname, H5T_NATIVE_DOUBLE, filespace, &
                         dset_id, error)  ! Create dataset

        call h5sclose_f(filespace, error) ! Close filespace

      else     ! not creating a new file, just adding data to an existing one.
        
        call h5pset_fapl_mpio_f(plist_id, tProcInfo_G%comm, mpiinfo, error)

!             re-open file in parallel
        
        call h5fopen_f(filename, H5F_ACC_RDWR_F, file_id, error, access_prp = plist_id)

!             re-open dataset in parallel

        call h5dopen_f (file_id, dsetname, dset_id, error)

        call h5pclose_f(plist_id, error)
        
      end if
      
      call h5screate_simple_f(rank, dims, dspace_id, error)

! For the space in memory

      if (nlonglength > 0) then

! for the corresponding space on disk

        call h5dget_space_f(dset_id, filespace, error)

!         Selecting slab on rank

        call h5sselect_hyperslab_f (filespace, H5S_SELECT_SET_F, doffset, &
                                    dims, error)

      else

!         all ranks must participate, so select no space to write when dealing
!         with ranks which hold no data for this field fr_real, etc

!          Selecting empty slab on rank

        call h5sselect_none_f(filespace,error)

      end if

      
      call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, error) 
      
      call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_INDEPENDENT_F, error)

!              Write data
      
      call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, rawdata, dims, error, &
                      xfer_prp = plist_id, file_space_id = filespace, &
                      mem_space_id = dspace_id)

!           Closing filespace

      call h5sclose_f(filespace, error)

!          Closing hyperslab space

      call h5sclose_f(dspace_id, error)



!          Closing property list

      call h5pclose_f(plist_id, error)

!          Closing dataset

      call h5dclose_f(dset_id, error)

!          Closing file

      call h5fclose_f(file_id, error)
      
!      end of parallel write stuff

!        add stuff just on rank 0

      if (createNewFlag .EQ. 1) then

        if (tProcInfo_G%qRoot) then 

!             Re-opening file in serial

          call h5fopen_f(filename, H5F_ACC_RDWR_F, file_id, error)

!             Re-opening dataset in serial

          call h5dopen_f (file_id, dsetname, dset_id, error)

!            Creating scalar space

          call h5screate_f(H5S_SCALAR_F, aspace_id, error)

          call h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)

! Create dataset integer attributes.
! Always ndim=3 even if 1D as 1 cell in both transverse dims but same
! postprocessing should work, and make possible to display vs particles

          aname = "vsNumSpatialDims"    

          call h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)

!              Write the attribute data.
          call h5awrite_f(attr_id, atype_id, 1, adims, error) !

!                Close the attribute.
          call h5aclose_f(attr_id, error)

!              next attribute
          aname="numSpatialDims"
          call h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
          call h5awrite_f(attr_id, atype_id, 1, adims, error) 
          call h5aclose_f(attr_id, error)
          call h5tclose_f(atype_id, error)

!     Create dataset floating point attributes.

          call writeCommonAtts(dset_id, time, sz_loc, iL, aspace_id)

!          call addH5FloatAttribute(dset_id, "time", time,aspace_id)
!          call addH5FloatAttribute(dset_id, "zBarInter", time, aspace_id)
!          call addH5FloatAttribute(dset_id, "zInter", time*lg_G, aspace_id)
!
!          call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!          call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!          call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!          call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!          call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!          call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)


          call addH5StringAttribute(dset_id,"vsLabels","aperp_real, aperp_imaginary",aspace_id)
          call addH5StringAttribute(dset_id,"vsType","variable",aspace_id)
          call addH5StringAttribute(dset_id,"vsCentering","nodal",aspace_id)

          if (qoned_g) then
          
            call addH5StringAttribute(dset_id,"vsIndexOrder","compMinorF",aspace_id)
          
          else
          
            call addH5StringAttribute(dset_id,"vsIndexOrder","compMajorF",aspace_id)
          
          end if 

          call addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
          call addH5StringAttribute(dset_id,"vsLimits",limgrpname,aspace_id)
          call addH5StringAttribute(dset_id,"vsMesh",meshScaledGrpname,aspace_id)
          call addH5StringAttribute(dset_id,"vsAxisLabels","z2",aspace_id)
          call h5dclose_f(dset_id, error)	  

!                       Time Group 

          call writeH5TimeGroup(file_id, timegrpname, time, &
                                'radH5Field1D', error)

          call writeH5RunInfo(file_id, 'radH5Field1D', error)

          lb=0.0_WP*sLengthOfElmZ2_G  ! Lower and upper bounds...
          ub=NZ2_G*sLengthOfElmZ2_G

          call write1DlimGrp(file_id,limgrpname,lb,ub)
          call write1DuniformMesh(file_id,meshScaledGrpname,lb,ub,(NZ2_G-1),"z2,A_perp radiation field")

          aname="intensityScaled"
          attr_data_string="sqr(aperp_real)+sqr(aperp_imaginary)"
          attr_string_len=len(trim(adjustl(attr_data_string)))

          call addH5derivedVariable(file_id,aname,attr_data_string,error)

          call h5fclose_f(file_id, error)

        end if

      end if

    end if

  end subroutine outputH5Field1D2CompSD



!> outputH5Field3DoldD is for writing the full field output.
!! This version dumps on each rank separately.
  subroutine outputH5Field3DoldD(sA, time, error)
    implicit none
    real(kind=wp), intent(in) :: sA(:)
    REAL(kind=WP), intent(in) :: time
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: dset_id       !< Dataset identifier 
    INTEGER(HID_T) :: dspace_id     !< Dataspace identifier in memory
    INTEGER(HID_T) :: filespace     !< Dataspace identifier in file
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
! may yet need this, but field data is not separated amongst cores
!    logical, intent(in) :: qSeparate
    CHARACTER(LEN=5), PARAMETER :: dsetname = "aperp"     ! Dataset name
    CHARACTER(LEN=16) :: aname   ! Attribute name
!    character(1024_IP), intent(in) :: zDFName
    character(1024_IP) :: filename
    INTEGER(HSIZE_T), DIMENSION(4) :: dims 
! Data as component*reducedNX*reducedNY*reducedNZ2
! Not described as a parameter, so can prob modify 
! for single component (rank 3 data) like charge
    INTEGER     ::   rank = 4               !< Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: adims !< Attribute dims
    REAL(kind=WP) :: attr_data_double       !< holder of attribute double data
    CHARACTER(LEN=100) :: attr_data_string  !< holder of attribute strings 
    INTEGER(HSIZE_T) :: attr_string_len     !< length of attribute strings
    INTEGER(kind=IP) :: numSpatialDims      !< Attr content,  
    INTEGER     ::  arank = 1               !< Attribute Dataset rank (1: vector)
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  !< Name of time group
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  !< Name of limits grp
    CHARACTER(LEN=10), PARAMETER :: meshScaledGrpname = "meshScaled" !< Name of mesh grp
    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshSI"  !< Dummy scaled mesh grp name
    REAL(kind=WP), ALLOCATABLE :: limdata (:)  !< Data to write (diff for 1D and 3D)
    INTEGER(kind=IP), ALLOCATABLE :: numcelldata (:)  !< Mesh info for uniform grid
    ! Local vars
    integer :: error !< Error flag

    if (qONED_G) then
      numSpatialDims=1
    else
      numSpatialDims=3
    end if

!    Print*,('Spatialdims: ' // trim(IntegerToString(numSpatialDims)))

!Fields are all available to rank zero, and we will worry about
!parallel writing this in due course. 
    if (tProcInfo_G%qRoot) then
      dims = (/NX_G,NY_G,NZ2_G,2/) ! Dataset dimensions

      filename = (trim(adjustl(zFilename_G)) // '_aperp_' &
        // trim(adjustl(IntegerToString(tProcInfo_G%Rank))) &
        // '_' //trim(adjustl(IntegerToString(iStep))) &
        // '.h5' )
!      PRINT *,'size of sA'
!      PRINT *, size(sA)
      CALL h5open_f(error)

      CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(file created)'
!
! Create the big dataspace in the file.
!
      CALL h5screate_simple_f(rank, dims, filespace, error)
!      Print*,'hdf5_puff:outputH5Field(filespace created)'
!      Print*,error
!
! Create the dataset with default properties.
!
      CALL h5dcreate_f(file_id, dsetname, H5T_NATIVE_DOUBLE, filespace, &
       dset_id, error)
!      Print*,'hdf5_puff:outputH5Field(dataset created)'
!      Print*,error

! We do not need to Create a space in memory to buffer the data writes
! for a serial (rank 0 only write), but may need this for parallel write
! where we'll want to grab a slice of sA for writing
!      CALL h5screate_simple_f(rank, dims, dspace_id, error)
!      Print*,'hdf5_puff:outputH5BeamFiles(memory dataspace allocated)'

!  try without dataspaces
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sA, dims, error)
!      Print*,'hdf5_puff:outputH5Field(write done)'
!      Print*,error

!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sA, dims, error, &
!        file_space_id = filespace, mem_space_id = dspace_id)
      CALL h5sclose_f(filespace, error)
!      Print*,'hdf5_puff:outputH5Field(filespace closed)'
!      Print*,error
!

! ATTRIBUTES FOR FIELD DATASET
!
! scalar dataset for simpler values
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,'hdf5_puff:outputH5Field(scalar space created)'

! Attributes of type double float first.
!
! Create datatype for the attribute.
!
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    aname="time"
    attr_data_double=time
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)

! then text attributes
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(atype_id set to string)'
    aname="vsLabels"
    attr_data_string="APerp_Re_scaled,APerp_Im_scaled"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(lables attribute created)'
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:outputH5BeamFiles(lables attribute written)'
!    print*,error
    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:outputH5Field3D(type attribute closed)'
!    print*,error

    aname="vsType"
    attr_data_string="variable"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute created)'
!    print*,error
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute written)'
!    print*,error
    CALL h5aclose_f(attr_id, error)
    aname="vsCentering"
    attr_data_string="nodal"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute created)'
!    print*,error
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute written)'
    CALL h5aclose_f(attr_id, error)
    CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMajorF",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
    CALL addH5StringAttribute(dset_id,"vsLimits",limgrpname,aspace_id)
    CALL addH5StringAttribute(dset_id,"vsMesh",meshScaledGrpname,aspace_id)
    CALL h5dclose_f(dset_id, error)
	  
! Time Group 
    CALL writeH5TimeGroup(file_id, timegrpname, time, &
	     'outH5Field3D', error)
    CALL writeH5RunInfo(file_id, 'outH5Field3D', error)
	
!	  CALL writeH5Field3DderivedVars(file_id, error)
	
! We make a group for the limits of the field data
    CALL h5gcreate_f(file_id, limgrpname, group_id, error)
    CALL addH5StringAttribute(group_id,"vsType","limits",aspace_id)
    CALL addH5StringAttribute(group_id,"vsKind","Cartesian",aspace_id)
    CALL h5sclose_f(aspace_id, error)
! And the limits themselves which require non-scalar attributes
    adims = (/numSpatialDims/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field(lim group lower bounds attribute created)'
    ALLOCATE ( limdata(numSpatialDims))
    limdata(1)=-0.5*(NX_G-1_IP)*sLengthOfElmX_G
    limdata(2)=-0.5*(NY_G-1_IP)*sLengthOfElmY_G
    limdata(3)=0.0
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    !Print*,error
    CALL h5aclose_f(attr_id, error)
    !Print*,error
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field(lim group upper bounds attribute created)'
!    Print*,error
    limdata(1)=0.5*(NX_G-1)*sLengthOfElmX_G
    limdata(2)=0.5*(NY_G-1)*sLengthOfElmY_G
    limdata(3)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)
    CALL h5sclose_f(aspace_id, error)    
    CALL h5gclose_f(group_id, error)

! We make a SI mesh group
    CALL h5gcreate_f(file_id, meshSIGrpname, group_id, error)
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
    aname="vsType"
    attr_data_string="mesh"
    attr_string_len=4
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    !Print*,error   
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,'hdf5_puff:outputH5Field(scalar attribute space created)'
!    Print*,error   
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,error   
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,error   
    CALL h5aclose_f(attr_id, error)
!    Print*,error   
    aname="vsIndexOrder"
    attr_data_string="compMajorF"
    attr_string_len=10
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute created)'
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute written)'
    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(type attribute closed)'
!    print*,error
    aname="vsCentering"
    attr_data_string="nodal"
    attr_string_len=len(attr_data_string)
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsKind"
    attr_data_string="uniform"
    attr_string_len=len(attr_data_string)
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5tclose_f(atype_id, error)
    CALL h5aclose_f(attr_id, error)
    CALL h5sclose_f(aspace_id, error)
! And the limits themselves which require non-scalar attributes
    adims = (/numSpatialDims/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    Print*,'hdf5_puff:outputH5Field(SI lim group mesh lower bounds attribute created)'
    ALLOCATE ( limdata(numSpatialDims))
    limdata(1)=-0.5*(NX_G-1)*sLengthOfElmX_G*DSQRT(lg_G*lc_G)
    limdata(2)=-0.5*(NY_G-1)*sLengthOfElmY_G*DSQRT(lg_G*lc_G)
    limdata(3)=0.0*lc_G
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    Print*,'hdf5_puff:outputH5Field(SI lim group mesh upper bounds attribute created)'
    limdata(1)=0.5*(NX_G-1)*sLengthOfElmX_G*DSQRT(lg_G*lc_G)
    limdata(2)=0.5*(NY_G-1)*sLengthOfElmY_G*DSQRT(lg_G*lc_G)
    limdata(3)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G*lc_G
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)
    CALL h5gclose_f(group_id, error)



! We make the scaled mesh group
    CALL h5gcreate_f(file_id, meshScaledGrpname, group_id, error)
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
    aname="vsType"
    attr_data_string="mesh"
    attr_string_len=4
    CALL h5tset_size_f(atype_id, attr_string_len, error)
!    Print*,error   
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,'hdf5_puff:outputH5Field(scalar attribute space created)'
!    Print*,error   
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,error   
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,error   
    CALL h5aclose_f(attr_id, error)
!    Print*,error   
    aname="vsIndexOrder"
    attr_data_string="compMajorF"
    attr_string_len=10
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsCentering"
    attr_data_string="nodal"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsKind"
    attr_data_string="uniform"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5tclose_f(atype_id, error)
    CALL h5aclose_f(attr_id, error)
    CALL h5sclose_f(aspace_id, error)
! And the limits themselves which require non-scalar attributes
    adims = (/numSpatialDims/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field(mesh lower bounds attribute created)'
    ALLOCATE ( limdata(numSpatialDims))
    limdata(1)=-0.5*(NX_G-1)*sLengthOfElmX_G
    limdata(2)=-0.5*(NY_G-1)*sLengthOfElmY_G
    limdata(3)=0.0
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field(mesh upper bounds attribute created)'
    limdata(1)=0.5*(NX_G-1)*sLengthOfElmX_G
    limdata(2)=0.5*(NY_G-1)*sLengthOfElmY_G
    limdata(3)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)

! Integers
    aname="vsStartCell"
    CALL h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field(startcell attribute created)'
    ALLOCATE ( numcelldata(numSpatialDims))
    numcelldata(1)=0
    numcelldata(2)=0
    numcelldata(3)=0
    CALL h5awrite_f(attr_id, atype_id, numcelldata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsNumCells"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field(numcells attribute created)'
    numcelldata(1)=NX_G-1
    numcelldata(2)=NY_G-1
    numcelldata(3)=NZ2_G-1
    CALL h5awrite_f(attr_id, atype_id, numcelldata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( numcelldata)
    CALL h5tclose_f(atype_id, error)

    CALL h5sclose_f(aspace_id, error)
    
    CALL h5gclose_f(group_id, error)

! We make another group
!    CALL h5gcreate_f(file_id, "intensityScaled", group_id, error)
!    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
!    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    aname="vsType"
!    attr_data_string="vsVars"
!    attr_string_len=len(trim(adjustl(attr_data_string)))
!    CALL h5tset_size_f(atype_id, attr_string_len, error)
!    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    CALL h5aclose_f(attr_id, error)
    aname="intensityScaled"
    attr_data_string="sqr(APerp_Re_scaled)+sqr(APerp_Im_scaled)"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL addH5derivedVariable(file_id,aname,attr_data_string,error)
!    CALL h5tset_size_f(atype_id, attr_string_len, error)
!    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    CALL h5aclose_f(attr_id, error)
!    CALL h5tclose_f(atype_id, error)
!    CALL h5sclose_f(aspace_id, error)
!    CALL h5gclose_f(group_id, error)
!
! Close the file.
!
      CALL h5fclose_f(file_id, error)
    End If 

!      if (tProcInfo_G%qRoot) then

  end subroutine outputH5Field3DoldD

!> CreateIntegrated1DFloat(simtime,error)
!! Creates a single integrated file for the 1D datasets
  subroutine CreateIntegrated1DFloat(simtime,error,nslices)

    implicit none

    REAL(kind=WP), intent(in) :: simtime      !< simulation time
    INTEGER(kind=IP),intent(in) :: nslices       !< Number of slices
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  !< Time Group name
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  !< Lims Group name
    CHARACTER(LEN=14), PARAMETER :: limgrpnameSI = "globalLimitsSI"  !< Lims Group name
    CHARACTER(LEN=10), PARAMETER :: meshScaledGrpname = "meshScaled" !< Mesh Group name
    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshSI"  !< SI Mesh Group name
    character(1024_IP) :: filename !< output filename
    REAL(kind=WP), ALLOCATABLE :: limdata (:)  !< dataset containing limits to write
    INTEGER(kind=IP), ALLOCATABLE :: numcelldata (:)  !< Dataset to write with numcells
    integer(kind=ip) :: error !< Local Error flag
    if (tProcInfo_G%qRoot) then
      filename = ( trim(adjustl(zFilename_G)) // '_integrated_' &
         // trim(adjustl(IntegerToString(tProcInfo_G%Rank))) &
        // '_' //trim(adjustl(IntegerToString(iCSteps))) &
        // '.h5' )
      CALL h5open_f(error)
      CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error)
      CALL writeH5TimeGroup(file_id, timegrpname, simtime, 'intH5field1D', error)
      CALL writeH5RunInfo(file_id, 'integratedH5Field1D', error)
! Limits group
!      CALL h5gcreate_f(file_id, limgrpname, group_id, error)
      CALL write1DlimGrp(file_id,limgrpname,0._wp,real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G)
      CALL write1DlimGrp(file_id,limgrpnameSI,0._wp,real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G*lc_g)
      CALL write1DuniformMesh(file_id,"intFieldMeshSc",0._wp, &
        real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G,NZ2_G,"z2,scaled parameter")
      CALL write1DuniformMesh(file_id,"intPtclMeshSc",0._wp, &
        real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G,nslices,"z2,scaled parameter")
      CALL write1DuniformMesh(file_id,"intFieldMeshSI",0._wp, &
        real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G*lc_g,NZ2_g,"z2 [m], SI parameter")
      CALL write1DuniformMesh(file_id,"intPtclMeshSI",0._wp, &
        real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G*lc_g,nslices,"z2 [m], SI parameter")
!
! Close the file.
!
      CALL h5fclose_f(file_id, error)
      CALL h5close_f(error)
    end if 
  end subroutine   CreateIntegrated1DFloat
!>addH5Field1DFloat() This subroutine writes data
  subroutine addH5Field1DFloat(writeData, dsetname, scalefac, meshname, simtime, &
                               sz_loc, iL, error)

    implicit none

    character(1024_IP) :: filename !< output filename
    integer(kind=ip) :: error !< Local Error flag
    real(kind=wp), intent(in) :: writeData(:) !< data to be written
    real(kind=wp), allocatable :: writeDataSI(:) !< data to be written
    CHARACTER(LEN=*), intent(in) :: dsetname  !< Dataset name
    REAL(kind=WP), intent(in) :: scalefac      !< scaling factor for SI var
    CHARACTER(LEN=*), INTENT(IN) :: meshname !<name of mesh to assign integrated data
    REAL(kind=WP), intent(in) :: simtime      !< simulation time
    real(kind=wp), intent(in) :: sz_loc  !< zbar local to the current undulator module
    integer(kind=ip), intent(in) :: iL !< Lattice element number
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: dset_id       !< Dataset identifier 
    INTEGER(HID_T) :: filespace     !< Dataspace identifier in file
    INTEGER(HID_T) :: dspace_id     !< Dataspace identifier in memory
    INTEGER     ::   rank = 1               !< Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: dims  !< Dataset dimensionality
    INTEGER(HSIZE_T), DIMENSION(1) :: adims !< Attribute dims
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    CHARACTER(LEN=40) :: aname   !< Attribute name
    REAL(kind=WP) :: attr_data_double       !< for attrs of type double
    CHARACTER(LEN=100) :: attr_data_string  !< attrs of type string
    INTEGER(HSIZE_T) :: attr_string_len     !< len of attrs of type string
    INTEGER(kind=IP) :: numSpatialDims = 1  !< Attr content,  
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  !< Time Group name
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  !< Lims Group name
    CHARACTER(LEN=14), PARAMETER :: limgrpnameSI = "globalLimitsSI"  !< Lims Group name
!    CHARACTER(LEN=10), PARAMETER :: meshScaledGrpname = "meshScaled" !< Mesh Group name
!    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshSI"  !< SI Mesh Group name
!    CHARACTER(LEN=15), PARAMETER :: meshScaledGrpname = "meshIntPtclData" !< Mesh Group name
!    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshIntPtclSI"  !< SI Mesh Group name
    CHARACTER(LEN=40) :: scaleToSIstring !< placeholder for scaling factor strings
    INTEGER     ::  arank = 1               !< Attribute Dataset rank
    if (tProcInfo_G%qRoot) then
      dims = size(writeData) ! Dataset dimensions
      filename = ( trim(adjustl(zFilename_G)) // '_integrated_' &
         // trim(adjustl(IntegerToString(tProcInfo_G%Rank))) &
        // '_' //trim(adjustl(IntegerToString(iCSteps))) &
        // '.h5' )
      CALL h5open_f(error)
      CALL h5fopen_f(filename, H5F_ACC_RDWR_F, file_id, error)
      CALL h5screate_simple_f(rank, dims, filespace, error)
      CALL h5dcreate_f(file_id, trim(adjustl(dsetname)), H5T_NATIVE_DOUBLE, filespace, &
        dset_id, error)
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, writeData, dims, error)
      CALL h5sclose_f(filespace, error)
! scalar dataset for simpler values
      CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)

      call writeCommonAtts(dset_id, simtime, sz_loc, iL, aspace_id)

      
      
      CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
      aname="vsLabels"
      attr_data_string=trim(adjustl(dsetname))
      attr_string_len=len(trim(adjustl(dsetname))) 
      CALL h5tset_size_f(atype_id, attr_string_len, error)
      CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
      CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
      CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
      CALL h5aclose_f(attr_id, error)
      CALL addH5StringAttribute(dset_id,"vsType","variable",aspace_id)
      if (size(writeData) .eq. NZ2_G) then
        CALL addH5StringAttribute(dset_id,"vsCentering","nodal",aspace_id) 
      else
        CALL addH5StringAttribute(dset_id,"vsCentering","zonal",aspace_id) 
      end if
      CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMinorF",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsLimits",limgrpnameSI,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsMesh",(meshname//"Sc"),aspace_id)
      CALL addH5StringAttribute(dset_id,"vsAxisLabels","z2,"//dsetname//"(scaled)",aspace_id)
!      aname=trim(adjustl(dsetname)) // "SI"
!      write(scaleToSIstring, '(E16.9)' ) (scalefac) 
!      attr_data_string=(trim(adjustl(dsetname)) // "*" // scaleToSIstring)
!      attr_string_len=len(trim(adjustl(attr_data_string)))
!      CALL addH5derivedVariableSI(file_id,aname,attr_data_string,meshname,error)

      CALL h5sclose_f(aspace_id, error)
      CALL h5dclose_f(dset_id, error)

      CALL h5screate_simple_f(rank, dims, filespace, error)
      CALL h5dcreate_f(file_id, trim(adjustl(dsetname // "SI")), H5T_NATIVE_DOUBLE, filespace, &
        dset_id, error)
      allocate(writeDataSI(size(writeData)))
      writeDataSI=writeData*scalefac
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, writeDataSI, dims, error)
      deallocate(writeDataSI)
      CALL h5sclose_f(filespace, error)
! scalar dataset for simpler values
      CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
      
      call writeCommonAtts(dset_id, simtime, sz_loc, iL, aspace_id)
      
!      CALL addH5FloatAttribute(dset_id, "time", simtime, aspace_id)
!      CALL addH5FloatAttribute(dset_id, "zbarInter", simtime, aspace_id)
!      CALL addH5FloatAttribute(dset_id, "zInter", simtime * lg_G, aspace_id)
!
!      CALL addH5IntegerAttribute(dset_id, "iCsteps", iCsteps, aspace_id)
!      CALL addH5IntegerAttribute(dset_id, "istep", istep, aspace_id)
!      
!      call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!      call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)      
      
      
      CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
      aname="vsLabels"
      attr_data_string=trim(adjustl(dsetname))
      attr_string_len=len(trim(adjustl(dsetname))) 
      CALL h5tset_size_f(atype_id, attr_string_len, error)
      CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
      CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
      CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
      CALL h5aclose_f(attr_id, error)
      CALL addH5StringAttribute(dset_id,"vsType","variable",aspace_id)
      if (size(writeData) .eq. NZ2_G) then
        CALL addH5StringAttribute(dset_id,"vsCentering","nodal",aspace_id) 
      else
        CALL addH5StringAttribute(dset_id,"vsCentering","zonal",aspace_id) 
      end if
      CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMinorF",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsLimits",limgrpname,aspace_id)
      CALL addH5StringAttribute(dset_id,"vsMesh",(meshname//"SI"),aspace_id)
      CALL addH5StringAttribute(dset_id,"vsAxisLabels","z2 [m],"//dsetname//"(SI)",aspace_id)
      CALL addH5StringAttribute(dset_id,"vsAxisUnits","m,(SI)",aspace_id)
      CALL h5sclose_f(aspace_id, error)
      CALL h5dclose_f(dset_id, error)

 
      CALL h5fclose_f(file_id, error)
      CALL h5close_f(error)
    end if
  end subroutine addH5Field1DFloat

!> outputH5Field1DFloat
!! Output a 1D, 1 comp float eg of radiation power, electron current, etc
!! 
  subroutine outputH5Field1DFloat(writeData, dsetname, simtime, sz_loc, iL, error)

    implicit none

    real(kind=wp), intent(in) :: writeData(:) !< data to be written
    real(kind=wp), intent(in) :: simtime      !< simulation time
    real(kind=wp), intent(in) :: sz_loc   !< zbar local to current undulator module 
    CHARACTER(LEN=*), intent(in) :: dsetname  !< Dataset name
    integer(kind=ip), intent(in) :: iL  !< Lattice element number
    INTEGER(HID_T) :: file_id       !< File identifier
    INTEGER(HID_T) :: dset_id       !< Dataset identifier 
    INTEGER(HID_T) :: dspace_id     !< Dataspace identifier in memory
    INTEGER(HID_T) :: filespace     !< Dataspace identifier in file
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
! may yet need this, but field data is not separated amongst cores
!    logical, intent(in) :: qSeparate
! assumed these files will be small and written on rank0 for now
    CHARACTER(LEN=16) :: aname   !< Attribute name
    character(1024_IP) :: filename !< output filename
    INTEGER(HSIZE_T), DIMENSION(1) :: dims  !< Dataset dimensionality
    INTEGER     ::   rank = 1               !< Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: adims !< Attribute dims
    REAL(kind=WP) :: attr_data_double       !< for attrs of type double
    CHARACTER(LEN=100) :: attr_data_string  !< attrs of type string
    INTEGER(HSIZE_T) :: attr_string_len     !< len of attrs of type string
    INTEGER(kind=IP) :: numSpatialDims = 1  !< Attr content,  
    INTEGER     ::  arank = 1               !< Attribute Dataset rank
    CHARACTER(LEN=4), PARAMETER :: timegrpname = "time"  !< Time Group name
    CHARACTER(LEN=12), PARAMETER :: limgrpname = "globalLimits"  !< Lims Group name
    CHARACTER(LEN=10), PARAMETER :: meshScaledGrpname = "meshScaled" !< Mesh Group name
    CHARACTER(LEN=6), PARAMETER :: meshSIGrpname = "meshSI"  !< SI Mesh Group name
    CHARACTER(LEN=16) :: scaleToSIstring !< placeholder for scaling factor strings
    REAL(kind=WP), ALLOCATABLE :: limdata (:)  !< dataset containing limits to write
    INTEGER(kind=IP), ALLOCATABLE :: numcelldata (:)  !< Dataset to write with numcells
    ! Local vars    integer :: error ! Error flag
    integer(kind=ip) :: error !< Local Error flag

!Fields are all available to rank zero, and we will worry about
!parallel writing this in due course. 
    if (tProcInfo_G%qRoot) then
      dims = size(writeData) ! Dataset dimensions

      filename = ( trim(adjustl(zFilename_G)) // '_' // trim(adjustl(dsetname)) & 
	    // '_' // trim(adjustl(IntegerToString(tProcInfo_G%Rank))) &
        // '_' //trim(adjustl(IntegerToString(iCSteps))) &
        // '.h5' )
!      PRINT *,'size of writeData: ' // trim(adjustl(dsetname))
!      PRINT *, dims
      
      CALL h5open_f(error)
!
! Create a new file using default properties.
!
      CALL h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error)
!    Print*,'hdf5_puff:outputH5BeamFiles(file created)'
!
! Create the big dataspace in the file.
!
      CALL h5screate_simple_f(rank, dims, filespace, error)
!      Print*,'hdf5_puff:outputH5power(filespace created)'
!      Print*,error
!
! Create the dataset with default properties.
!
      CALL h5dcreate_f(file_id, trim(adjustl(dsetname)), H5T_NATIVE_DOUBLE, filespace, &
       dset_id, error)
!
! Create a space in memory to buffer the data writes
!
!      CALL h5screate_simple_f(rank, dims, dspace_id, error)
!      Print*,'hdf5_puff:outputH5BeamFiles(memory dataspace allocated)'

!  try without dataspaces
      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, writeData, dims, error)
!      Print*,'hdf5_puff:outputH5power(write done)'
!      Print*,error
!      CALL h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, sA, dims, error, &
!        file_space_id = filespace, mem_space_id = dspace_id)
      CALL h5sclose_f(filespace, error)
!      Print*,'hdf5_puff:outputH5power(filespace closed)'
!      Print*,error

! ATTRIBUTES FOR FIELD DATASET
!
! simple dataset for array of vals
!    CALL h5screate_simple_f(arank, adims, aspace_id, error)

! scalar dataset for simpler values
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,'hdf5_puff:outputH5power(scalar space created)'
!
! Create datatype for the attribute.
!
!    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
!    aname="time"
!    attr_data_double=1.0*iStep*sStepSize/c
!    attr_data_double=simtime
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    CALL h5aclose_f(attr_id, error)
!    CALL h5tclose_f(atype_id, error)

     call writeCommonAtts(dset_id, simtime, sz_loc, iL, aspace_id)
!     CALL addH5FloatAttribute(dset_id, "time", simtime, aspace_id)
!     CALL addH5FloatAttribute(dset_id, "zbarInter", simtime, aspace_id)
!     CALL addH5FloatAttribute(dset_id, "zInter", simtime*lg_G, aspace_id)
!
!     call addH5IntegerAttribute(dset_id, "iUnd_cr", iUnd_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iChic_cr", iChic_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iDrift_cr", iDrift_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iQuad_cr", iQuad_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, "iModulation_cr", iModulation_cr, aspace_id)
!     call addH5IntegerAttribute(dset_id, 'iL', iL, aspace_id)


    !      text attributes
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
    aname="vsLabels"
    attr_data_string=trim(adjustl(dsetname))
    attr_string_len=len(trim(adjustl(dsetname))) 
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5aclose_f(attr_id, error)
    CALL addH5StringAttribute(dset_id,"vsType","variable",aspace_id)
    if (size(writeData) .eq. NZ2_G) then
      CALL addH5StringAttribute(dset_id,"vsCentering","nodal",aspace_id) 
    else
      CALL addH5StringAttribute(dset_id,"vsCentering","zonal",aspace_id) 
    end if
    CALL addH5StringAttribute(dset_id,"vsIndexOrder","compMinorF",aspace_id)
    CALL addH5StringAttribute(dset_id,"vsTimeGroup",timegrpname,aspace_id)
    CALL addH5StringAttribute(dset_id,"vsLimits",limgrpname,aspace_id)
    CALL addH5StringAttribute(dset_id,"vsMesh",meshScaledGrpname,aspace_id)
!    aname="vsMesh"
!    attr_data_string=meshScaledGrpname
!    attr_string_len=len(meshScaledGrpname)
!    CALL h5tset_size_f(atype_id, attr_string_len, error)
!    CALL h5acreate_f(dset_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(mesh attributes created)'
!    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(mesh attributes closed)'
    CALL h5sclose_f(aspace_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(not closing scalar space)'
!    CALL h5tclose_f(atype_id, error)
!    Print*,error

      CALL h5dclose_f(dset_id, error)
!   Print*,'hdf5_puff:outputH5Field1D(close dataset work on groups)'
!    Print*,error
 
! Call the subroutine to create the time group
! CALL writeH5TimeGroup(file_id, timegrpname, simtime, trim(adjustl(dsetname)), error)
  CALL writeH5TimeGroup(file_id, timegrpname, simtime, 'outH5field1D', error)

  CALL writeH5RunInfo(file_id, 'outputH5Field1D', error)
	
! CALL writeH5Field1DderivedVars(file_id, error)
! CALL writeH5LimitsMesh1D
	
! We make another group
    CALL h5gcreate_f(file_id, limgrpname, group_id, error)
!    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    print*,"not opening space as not closed, and handy for timegrp, runinfo"
!    Print*,error
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,error
    CALL addH5StringAttribute(group_id,"vsType","limits",aspace_id)
    CALL addH5StringAttribute(group_id,"vsKind","Cartesian",aspace_id)
    CALL h5sclose_f(aspace_id, error)
! And the limits themselves which require non-scalar attributes
    adims = (/1/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(lower bounds attribute created)'
    ALLOCATE ( limdata(1))
    limdata(1)=0.0
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(upper bounds attribute created)'
    limdata(1)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)
    CALL h5sclose_f(aspace_id, error)
    CALL h5gclose_f(group_id, error)

! We make a mesh group
    CALL h5gcreate_f(file_id, meshScaledGrpname, group_id, error)
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
    CALL addH5StringAttribute(group_id,"vsType","mesh",aspace_id)
    CALL addH5StringAttribute(group_id,"vsIndexOrder","compMinorC",aspace_id)
    CALL addH5StringAttribute(group_id,"vsCentering","nodal",aspace_id)
    CALL addH5StringAttribute(group_id,"vsKind","uniform",aspace_id)
    CALL h5sclose_f(aspace_id, error)
! And the limits themselves which require non-scalar attributes
    adims = (/1/) 
    CALL h5screate_simple_f(arank, adims, aspace_id, error)
    aname="vsLowerBounds"
    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(mesh lower bounds attribute created)'
    ALLOCATE ( limdata(1))
    limdata(1)=0.0
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsUpperBounds"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1DFloat(mesh upper bounds attribute' &
!         // 'created)' // trim(adjustl(dsetname))
    limdata(1)=real((NZ2_G-1),kind=wp)*sLengthOfElmZ2_G
    CALL h5awrite_f(attr_id, atype_id, limdata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( limdata)
    CALL h5tclose_f(atype_id, error)

! Integers
    aname="vsStartCell"
    CALL h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1D(startcell attribute created)'
    ALLOCATE ( numcelldata(numSpatialDims))
    numcelldata(1)=0
    CALL h5awrite_f(attr_id, atype_id, numcelldata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    aname="vsNumCells"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:outputH5Field1DFloat(numcells attribute ' &
!	  // 'created)' // trim(adjustl(dsetname))
!    print*,NZ2_G-1
!    print*, size(writeData)
    if (size(writeData) .eq. NZ2_G) then
      numcelldata(1)=NZ2_G-1
    else
      numcelldata(1)=size(writeData)
    end if
    CALL h5awrite_f(attr_id, atype_id, numcelldata, adims, error) 
    CALL h5aclose_f(attr_id, error)
    DEALLOCATE ( numcelldata)
    CALL h5tclose_f(atype_id, error)
!    print*,error


    CALL h5sclose_f(aspace_id, error)
    
    CALL h5gclose_f(group_id, error)


!
! Close the file.
!
      CALL h5fclose_f(file_id, error)


    End If 

!      if (tProcInfo_G%qRoot) then

  end subroutine outputH5Field1DFloat

  subroutine writeH5TimeGroup(file_id, timegrpname, simtime, callerstr, error)

    INTEGER(HID_T) :: file_id       ! File identifier
    CHARACTER(LEN=4), intent(in) :: timegrpname  ! Group name
    REAL(kind=WP), intent(in) :: simtime ! Current time
    CHARACTER(LEN=12), intent(in) :: callerstr
    INTEGER(kind=ip) :: error
!
! Local
    INTEGER(HID_T) :: attr_id       ! Attribute identifier
    INTEGER(HID_T) :: aspace_id     ! Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      ! Attribute Data type identifier
    INTEGER(HID_T) :: group_id      ! Group identifier
    INTEGER     ::   rank = 1               ! Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: adims ! Attribute dims
    REAL(kind=WP) :: attr_data_double
    CHARACTER(LEN=100) :: attr_data_string
    INTEGER(HSIZE_T) :: attr_string_len
    INTEGER(kind=IP) :: numSpatialDims = 1   ! Attr content,  
    INTEGER     ::  arank = 1               ! Attribute Dataset rank
    CHARACTER(LEN=16) :: aname   ! Attribute name

! with the main dataset done we work on the other groups with attributes
! We make a group
    CALL h5gcreate_f(file_id, timegrpname, group_id, error)
!   Print*,'hdf5_puff:' // callerstr // '(group timegrpname created)'
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
!   Print*,'hdf5_puff:outputH5power(set timegrpname type)'
    CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
!    Print*,'hdf5_puff:outputH5power(string padding enabled)'
    aname="vsType"
    attr_data_string="time"
    attr_string_len=len(trim(adjustl(attr_data_string)))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
!   Print*,'hdf5_puff:outputH5power(set timegrpname size)'
!    Print*,error
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,('hdf5_puff:' // callerstr // '(scalar attr space created)')
!    Print*,error   
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    Print*,'hdf5_puff:' // callerstr // '(create timegrp vstype at)'
!    Print*,error
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    Print*,'hdf5_puff:' // callerstr // '(write timegrp vstype attr)'
!    Print*,error
    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:' // callerstr // '(close timegrp vstype attr)'
!    Print*,error

    CALL h5tclose_f(atype_id, error)
!    Print*,'hdf5_puff:' // callerstr // '(close timegrpname time attr-type )'
!    Print*,error

    CALL h5tcopy_f(H5T_NATIVE_DOUBLE, atype_id, error)
    aname="vsTime"
    attr_data_double=simtime
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    print*,'hdf5_puff:' // callerstr // ' create vstime attribute'
!    Print*,error
    CALL h5awrite_f(attr_id, atype_id, attr_data_double, adims, error) 
!    print*,'hdf5_puff:' // callerstr // ' write vstime attribute'
!    Print*,error
    CALL h5aclose_f(attr_id, error)
    CALL h5tclose_f(atype_id, error)
    CALL h5tcopy_f(H5T_NATIVE_INTEGER, atype_id, error)
    aname="vsStep"
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, iCSteps, adims, error) 
    CALL h5tclose_f(atype_id, error)
    CALL h5aclose_f(attr_id, error)
!    print*,'hdf5_puff:' // callerstr // ' close vsStep attribute'
    CALL h5sclose_f(aspace_id, error)
    CALL h5gclose_f(group_id, error)
!    Print*,error
!    Print*,'Closing timeGroup'
!    Print*,error

  end subroutine writeH5TimeGroup

!> writeH5RunInfo
!! Routine to write provenance data to the vizschema hdf5 files
!! @param file_id file identifier, location to put provenance data
!! @callerstr allows the passing in of information about what is
!!   asking for the run information to be written (ie parent routine)
   subroutine writeH5RunInfo(file_id, callerstr, error)

    INTEGER(HID_T), INTENT(in) :: file_id 
    CHARACTER(LEN=12), intent(in) :: callerstr
    INTEGER(kind=ip) :: error
!
! Local
    INTEGER(HID_T) :: attr_id       !< Attribute identifier
    INTEGER(HID_T) :: aspace_id     !< Attribute Dataspace identifier
    INTEGER(HID_T) :: atype_id      !< Attribute Data type identifier
    INTEGER(HID_T) :: group_id      !< Group identifier
    INTEGER     ::   rank = 1               !< Dataset rank
    INTEGER(HSIZE_T), DIMENSION(1) :: adims !< Attribute dims
    REAL(kind=WP) :: attr_data_double       !< attrib data (type double)
    CHARACTER(LEN=1024) :: attr_data_string !< attrib data (type string)
    INTEGER(HSIZE_T) :: attr_string_len     !< length of attrib string
    INTEGER(kind=IP) :: numSpatialDims = 1  !< Attr content, identifying nu 
    INTEGER     ::  arank = 1               !< Attribute Dataset rank
    CHARACTER(LEN=24) :: aname   ! Attribute name
    character(8)  :: date
    character(10) :: time
    character(5)  :: zone
    integer,dimension(8) :: values
    call date_and_time(date,time,zone,values)
 ! with the main dataset done we work on the other groups with attributes
! We make a group
    CALL h5gcreate_f(file_id, 'runInfo' , group_id, error)
 !   Print*,'hdf5_puff:' // callerstr // '(group runinfo created)'
    CALL h5tcopy_f(H5T_NATIVE_CHARACTER, atype_id, error)
    CALL h5tset_strpad_f(atype_id, H5T_STR_SPACEPAD_F, error)
    aname="vsType"
    attr_data_string="runInfo"
    attr_string_len=len(trim(attr_data_string))
    CALL h5tset_size_f(atype_id, attr_string_len, error)
    CALL h5screate_f(H5S_SCALAR_F, aspace_id, error)
!    Print*,('hdf5_puff:' // callerstr // '(scalar attr space created)')
!    Print*,error   
    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
    CALL h5aclose_f(attr_id, error)
!    Print*,'hdf5_puff:' // callerstr // '(close timegrpname time attr)'
!    Print*,error
    CALL addH5StringAttribute(group_id,"vsSoftware","PUFFIN",aspace_id)

!    write(attr_data_string, '(8i5)') values
!    write(attr_data_string, '(5i4-3i2-3i2) zone (4i3 3i2:3i2:3i2 .4i3)') values
    write(attr_data_string, '(a,a,a,a,a,2x,a,a,a,a,a,1x,a)') date(1:4),'-',date(5:6), &
      '-',date(7:8),time(1:2),':',time(3:4),':',time(5:10), zone
    CALL addH5StringAttribute(group_id,"vsRunDate",attr_data_string,aspace_id)
    CALL GETLOG(attr_data_string)
    CALL addH5StringAttribute(group_id,"vsUser",attr_data_string,aspace_id)
    CALL HOSTNM(attr_data_string)
    CALL addH5StringAttribute(group_id,"vsRunHost",attr_data_string,aspace_id)
    CALL addH5StringAttribute(group_id,"vsBuildConfigDate",'@CONFIGURE_TIME_STAMP@',aspace_id)

    attr_data_string='@GIT_BRANCH@ : @GIT_REVISION@' 
    CALL addH5StringAttribute(group_id,"vsSwRevision",attr_data_string,aspace_id)

    attr_data_string='@Puffin_VERSION_MAJOR@.@Puffin_VERSION_MINOR@.@Puffin_VERSION_PATCH@' 
    CALL addH5StringAttribute(group_id,"vsSwVersion",attr_data_string,aspace_id)
   
    CALL addH5StringAttribute(group_id,"vsVsVersion","3.0",aspace_id)
    CALL addH5StringAttribute(group_id,"vsFCompiler","@Fortran_COMPILER_NAME@",aspace_id)
    CALL addH5StringAttribute(group_id,"vsFCompilerVersion","@Fortran_VERSION@",aspace_id)
    CALL addH5StringAttribute(group_id,"vsFCompilerFlags","@CMAKE_Fortran_FLAGS@",aspace_id)
    CALL addH5StringAttribute(group_id,"vsBuildHost","@UQHOSTNAME@",aspace_id)
    CALL addH5StringAttribute(group_id,"vsBuildHostType","@CMAKE_HOST_SYSTEM@",aspace_id)

! required Fotran 2003. Not sure if we really want to do this.
    CALL get_command(attr_data_string)
    CALL addH5StringAttribute(group_id,"vsCommandLine",attr_data_string,aspace_id)
! rest I think is less sensitive to FORTRAN version


    CALL addH5StringAttribute(group_id,"vsInputFile",zFilename_G,aspace_id)
    CALL addH5StringAttribute(group_id,"vsBeamFile",zBFile_G,aspace_id)
    CALL addH5StringAttribute(group_id,"vsSeedFile",zSFile_G,aspace_id)
    
    call writeRunAtts(group_id, aspace_id)
    
!    aname="vsSeedFile"
!    attr_data_string=zSFile_G
!    attr_string_len=len(attr_data_string)
!    CALL h5tset_size_f(atype_id, attr_string_len, error)
!    CALL h5acreate_f(group_id, aname, atype_id, aspace_id, attr_id, error)
!    CALL h5awrite_f(attr_id, atype_id, attr_data_string, adims, error) 
!    CALL h5aclose_f(attr_id, error)
    CALL h5sclose_f(aspace_id, error)
!    Print*,error
    CALL h5tclose_f(atype_id, error)
    CALL h5gclose_f(group_id, error)
!    Print*,'Closing runInfo'
!    Print*,error

  end subroutine writeH5RunInfo
 
!  subroutine createH5Files(tArrayY, zDFName, zOptionalString, qOK)
!
!    implicit none

! Create "Full" Files - creates either 
! the full data sets for the field and 
! electron phase space.

!    type(cArraySegment), intent(inout) :: tArrayY(:)
!   character(1024_IP), intent(in)   ::   zDFName
!    character(*), intent(in), optional  :: zOptionalString
!    logical, intent(inout) :: qOK

!    integer(kind=ip) :: iap
!    character(1024_IP) :: zFileName
!    logical :: qOptional, qOKL



!    qOK = .false.
!    if (present(zOptionalString)) then
!      if (len(trim(adjustl(zOptionalString))) > 0) then
!        qOptional = .TRUE.
!      end if
!    end if
!     Loop around array segments, creating files
!    do iap = 1, size(tArrayY)
!      if (tArrayY(iap)%qWrite) then
!        if (tProcInfo_G%qRoot) then
!     Prepare filename      
!          zFilename = (trim(adjustl(tArrayY(iap)%zVariable)) // trim(adjustl(zDFName)) // '.h5')
!          if (qOptional) then
!            zFilename = (trim(adjustl(zOptionalString)) // '_' // trim(adjustl(zFilename)) // '.h5')
!          end if
!          call CreateSDDSFile(zFilename, &
!                              tArrayY(iap)%zVariable, &
!                              tArrayY(iap)%tFileType, &
!                              qOKL)    
!        end if
!     end if
!   end do
!     Set error flag and exit
!    qOK = .true.
!    goto 2000
!     Error Handler - Error log Subroutine in CIO.f90 line 709
!1000 call Error_log('Error in sddsPuffin:createFFiles',tErrorLog_G)
!    print*,'Error in sddsPuffin:createFFiles'
!2000 continue
!  end subroutine createH5Files


!> IntegerToString
!! Convert an integer into a string
!! Handy for filename substitution of dump number
!! @param  iInteger    - INPUT  - Integer to convert
FUNCTION IntegerToString(iInteger)

        IMPLICIT NONE
        INTEGER(KIND=IP), INTENT(IN) :: iInteger
        CHARACTER(32_IP) :: IntegerToString
! Define local variables
        CHARACTER(32_IP) :: zCharacter
! Write character to internal file
      write(zCharacter,*) iInteger
! Output without blanks
      IntegerToString = TRIM(ADJUSTL(zCharacter))
!  Set error flag and exit
       GoTo 2000
! Error Handler - Error log Subroutine in CIO.f90 line 709
1000 call Error_log('Error in sddsPuffin:IntegerToString',tErrorLog_G)
      Print*,'Error in sddsPuffin:IntegerToString'
2000 CONTINUE

END FUNCTION IntegerToString
	
	
end module hdf5_puff
